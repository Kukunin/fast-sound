(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("fs"));
	else if(typeof define === 'function' && define.amd)
		define(["fs"], factory);
	else if(typeof exports === 'object')
		exports["FastSound"] = factory(require("fs"));
	else
		root["FastSound"] = factory(root["fs"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_fs__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vRmFzdFNvdW5kLy4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcz9kZjdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/path-browserify/index.js\n");

/***/ }),

/***/ "./src/bundle.js":
/*!***********************!*\
  !*** ./src/bundle.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const WASM = __webpack_require__(/*! ../unminified/fast-sound.js */ \"./unminified/fast-sound.js\");\nconst Loader = __webpack_require__(/*! ./loader.js */ \"./src/loader.js\");\n\nmodule.exports = Loader(WASM, 'fast-sound.asm.js');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYnVuZGxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vRmFzdFNvdW5kLy4vc3JjL2J1bmRsZS5qcz84MTdlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFdBU00gPSByZXF1aXJlKCcuLi91bm1pbmlmaWVkL2Zhc3Qtc291bmQuanMnKTtcbmNvbnN0IExvYWRlciA9IHJlcXVpcmUoJy4vbG9hZGVyLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTG9hZGVyKFdBU00sICdmYXN0LXNvdW5kLmFzbS5qcycpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/bundle.js\n");

/***/ }),

/***/ "./src/loader.js":
/*!***********************!*\
  !*** ./src/loader.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(wasmObject, asmjsFilename) {\n  return function(options) {\n    options = options || {};\n\n    if(\"object\" === typeof WebAssembly && options['method'] !== 'asm.js') {\n      return wasmObject(options);\n    } else {\n      const readAsync = function(url, onload, onerror) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = 'text';\n        xhr.onload = function xhr_onload() {\n          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n            onload(xhr.response);\n            return;\n          }\n          onerror();\n        };\n        xhr.onerror = onerror;\n        xhr.send(null);\n      };\n\n      if('locateFile' in options) {\n        asmjsFilename = options['locateFile'](asmjsFilename);\n      }\n\n      return new Promise(function(resolve, reject) {\n        readAsync(asmjsFilename, function(script) {\n          const exports = {};\n          var module = eval(script);\n          module(options).then(function(lib) {\n            // to avoid infinite resolving loop\n            lib.then = undefined;\n            resolve(lib);\n          });\n        });\n      });\n    }\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbG9hZGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vRmFzdFNvdW5kLy4vc3JjL2xvYWRlci5qcz8zZDRjIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24od2FzbU9iamVjdCwgYXNtanNGaWxlbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYoXCJvYmplY3RcIiA9PT0gdHlwZW9mIFdlYkFzc2VtYmx5ICYmIG9wdGlvbnNbJ21ldGhvZCddICE9PSAnYXNtLmpzJykge1xuICAgICAgcmV0dXJuIHdhc21PYmplY3Qob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlYWRBc3luYyA9IGZ1bmN0aW9uKHVybCwgb25sb2FkLCBvbmVycm9yKSB7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiB4aHJfb25sb2FkKCkge1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwMCB8fCAoeGhyLnN0YXR1cyA9PSAwICYmIHhoci5yZXNwb25zZSkpIHsgLy8gZmlsZSBVUkxzIGNhbiByZXR1cm4gMFxuICAgICAgICAgICAgb25sb2FkKHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG9uZXJyb3IoKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgIH07XG5cbiAgICAgIGlmKCdsb2NhdGVGaWxlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGFzbWpzRmlsZW5hbWUgPSBvcHRpb25zWydsb2NhdGVGaWxlJ10oYXNtanNGaWxlbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmVhZEFzeW5jKGFzbWpzRmlsZW5hbWUsIGZ1bmN0aW9uKHNjcmlwdCkge1xuICAgICAgICAgIGNvbnN0IGV4cG9ydHMgPSB7fTtcbiAgICAgICAgICB2YXIgbW9kdWxlID0gZXZhbChzY3JpcHQpO1xuICAgICAgICAgIG1vZHVsZShvcHRpb25zKS50aGVuKGZ1bmN0aW9uKGxpYikge1xuICAgICAgICAgICAgLy8gdG8gYXZvaWQgaW5maW5pdGUgcmVzb2x2aW5nIGxvb3BcbiAgICAgICAgICAgIGxpYi50aGVuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVzb2x2ZShsaWIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/loader.js\n");

/***/ }),

/***/ "./unminified/fast-sound.js":
/*!**********************************!*\
  !*** ./unminified/fast-sound.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {\nvar FastSound = (function() {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  return (\nfunction(FastSound) {\n  FastSound = FastSound || {};\n\n// Copyright 2010 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof FastSound !== 'undefined' ? FastSound : {};\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// {{PRE_JSES}}\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = {};\nvar key;\nfor (key in Module) {\n  if (Module.hasOwnProperty(key)) {\n    moduleOverrides[key] = Module[key];\n  }\n}\n\nModule['arguments'] = [];\nModule['thisProgram'] = './this.program';\nModule['quit'] = function(status, toThrow) {\n  throw toThrow;\n};\nModule['preRun'] = [];\nModule['postRun'] = [];\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n\nvar ENVIRONMENT_IS_WEB = false;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\nENVIRONMENT_IS_WEB = typeof window === 'object';\nENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\nENVIRONMENT_IS_NODE = typeof process === 'object' && \"function\" === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\nENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\n\n// Three configurations we can be running in:\n// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\n// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\n// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\n\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = '';\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  } else {\n    return scriptDirectory + path;\n  }\n}\n\nif (ENVIRONMENT_IS_NODE) {\n  scriptDirectory = __dirname + '/';\n\n  // Expose functionality in the same simple way that the shells work\n  // Note that we pollute the global namespace here, otherwise we break in node\n  var nodeFS;\n  var nodePath;\n\n  Module['read'] = function shell_read(filename, binary) {\n    var ret;\n      if (!nodeFS) nodeFS = __webpack_require__(/*! fs */ \"fs\");\n      if (!nodePath) nodePath = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n      filename = nodePath['normalize'](filename);\n      ret = nodeFS['readFileSync'](filename);\n    return binary ? ret : ret.toString();\n  };\n\n  Module['readBinary'] = function readBinary(filename) {\n    var ret = Module['read'](filename, true);\n    if (!ret.buffer) {\n      ret = new Uint8Array(ret);\n    }\n    assert(ret.buffer);\n    return ret;\n  };\n\n  if (process['argv'].length > 1) {\n    Module['thisProgram'] = process['argv'][1].replace(/\\\\/g, '/');\n  }\n\n  Module['arguments'] = process['argv'].slice(2);\n\n  // MODULARIZE will export the module in the proper place outside, we don't need to export here\n\n  process['on']('uncaughtException', function(ex) {\n    // suppress ExitStatus exceptions from showing an error\n    if (!(ex instanceof ExitStatus)) {\n      throw ex;\n    }\n  });\n  // Currently node will swallow unhandled rejections, but this behavior is\n  // deprecated, and in the future it will exit with error status.\n  process['on']('unhandledRejection', abort);\n\n  Module['quit'] = function(status) {\n    process['exit'](status);\n  };\n\n  Module['inspect'] = function () { return '[Emscripten Module object]'; };\n} else\nif (ENVIRONMENT_IS_SHELL) {\n\n\n  if (typeof read != 'undefined') {\n    Module['read'] = function shell_read(f) {\n      return read(f);\n    };\n  }\n\n  Module['readBinary'] = function readBinary(f) {\n    var data;\n    if (typeof readbuffer === 'function') {\n      return new Uint8Array(readbuffer(f));\n    }\n    data = read(f, 'binary');\n    assert(typeof data === 'object');\n    return data;\n  };\n\n  if (typeof scriptArgs != 'undefined') {\n    Module['arguments'] = scriptArgs;\n  } else if (typeof arguments != 'undefined') {\n    Module['arguments'] = arguments;\n  }\n\n  if (typeof quit === 'function') {\n    Module['quit'] = function(status) {\n      quit(status);\n    }\n  }\n} else\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\n    scriptDirectory = self.location.href;\n  } else if (document.currentScript) { // web\n    scriptDirectory = document.currentScript.src;\n  }\n  // When MODULARIZE (and not _INSTANCE), this JS may be executed later, after document.currentScript\n  // is gone, so we saved it, and we use it here instead of any other info.\n  if (_scriptDir) {\n    scriptDirectory = _scriptDir;\n  }\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n  // otherwise, slice off the final part of the url to find the script directory.\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n  // and scriptDirectory will correctly be replaced with an empty string.\n  if (scriptDirectory.indexOf('blob:') !== 0) {\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);\n  } else {\n    scriptDirectory = '';\n  }\n\n\n  Module['read'] = function shell_read(url) {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.send(null);\n      return xhr.responseText;\n  };\n\n  if (ENVIRONMENT_IS_WORKER) {\n    Module['readBinary'] = function readBinary(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.responseType = 'arraybuffer';\n        xhr.send(null);\n        return new Uint8Array(xhr.response);\n    };\n  }\n\n  Module['readAsync'] = function readAsync(url, onload, onerror) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = function xhr_onload() {\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n        onload(xhr.response);\n        return;\n      }\n      onerror();\n    };\n    xhr.onerror = onerror;\n    xhr.send(null);\n  };\n\n  Module['setWindowTitle'] = function(title) { document.title = title };\n} else\n{\n}\n\n// Set up the out() and err() hooks, which are how we can print to stdout or\n// stderr, respectively.\n// If the user provided Module.print or printErr, use that. Otherwise,\n// console.log is checked first, as 'print' on the web will open a print dialogue\n// printErr is preferable to console.warn (works better in shells)\n// bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.\nvar out = Module['print'] || (typeof console !== 'undefined' ? console.log.bind(console) : (typeof print !== 'undefined' ? print : null));\nvar err = Module['printErr'] || (typeof printErr !== 'undefined' ? printErr : ((typeof console !== 'undefined' && console.warn.bind(console)) || out));\n\n// Merge back in the overrides\nfor (key in moduleOverrides) {\n  if (moduleOverrides.hasOwnProperty(key)) {\n    Module[key] = moduleOverrides[key];\n  }\n}\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\nmoduleOverrides = undefined;\n\n\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n// {{PREAMBLE_ADDITIONS}}\n\nvar STACK_ALIGN = 16;\n\n\nfunction staticAlloc(size) {\n  var ret = STATICTOP;\n  STATICTOP = (STATICTOP + size + 15) & -16;\n  return ret;\n}\n\nfunction dynamicAlloc(size) {\n  var ret = HEAP32[DYNAMICTOP_PTR>>2];\n  var end = (ret + size + 15) & -16;\n  HEAP32[DYNAMICTOP_PTR>>2] = end;\n  if (end >= TOTAL_MEMORY) {\n    var success = enlargeMemory();\n    if (!success) {\n      HEAP32[DYNAMICTOP_PTR>>2] = ret;\n      return 0;\n    }\n  }\n  return ret;\n}\n\nfunction alignMemory(size, factor) {\n  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n  var ret = size = Math.ceil(size / factor) * factor;\n  return ret;\n}\n\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case 'i1': case 'i8': return 1;\n    case 'i16': return 2;\n    case 'i32': return 4;\n    case 'i64': return 8;\n    case 'float': return 4;\n    case 'double': return 8;\n    default: {\n      if (type[type.length-1] === '*') {\n        return 4; // A pointer\n      } else if (type[0] === 'i') {\n        var bits = parseInt(type.substr(1));\n        assert(bits % 8 === 0);\n        return bits / 8;\n      } else {\n        return 0;\n      }\n    }\n  }\n}\n\nfunction warnOnce(text) {\n  if (!warnOnce.shown) warnOnce.shown = {};\n  if (!warnOnce.shown[text]) {\n    warnOnce.shown[text] = 1;\n    err(text);\n  }\n}\n\nvar asm2wasmImports = { // special asm2wasm imports\n    \"f64-rem\": function(x, y) {\n        return x % y;\n    },\n    \"debugger\": function() {\n        debugger;\n    }\n};\n\n\n\nvar jsCallStartIndex = 1;\nvar functionPointers = new Array(0);\n\n// 'sig' parameter is only used on LLVM wasm backend\nfunction addFunction(func, sig) {\n  var base = 0;\n  for (var i = base; i < base + 0; i++) {\n    if (!functionPointers[i]) {\n      functionPointers[i] = func;\n      return jsCallStartIndex + i;\n    }\n  }\n  throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';\n}\n\nfunction removeFunction(index) {\n  functionPointers[index-jsCallStartIndex] = null;\n}\n\nvar funcWrappers = {};\n\nfunction getFuncWrapper(func, sig) {\n  if (!func) return; // on null pointer, return undefined\n  assert(sig);\n  if (!funcWrappers[sig]) {\n    funcWrappers[sig] = {};\n  }\n  var sigCache = funcWrappers[sig];\n  if (!sigCache[func]) {\n    // optimize away arguments usage in common cases\n    if (sig.length === 1) {\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func);\n      };\n    } else if (sig.length === 2) {\n      sigCache[func] = function dynCall_wrapper(arg) {\n        return dynCall(sig, func, [arg]);\n      };\n    } else {\n      // general case\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func, Array.prototype.slice.call(arguments));\n      };\n    }\n  }\n  return sigCache[func];\n}\n\n\nfunction makeBigInt(low, high, unsigned) {\n  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));\n}\n\nfunction dynCall(sig, ptr, args) {\n  if (args && args.length) {\n    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n  } else {\n    return Module['dynCall_' + sig].call(null, ptr);\n  }\n}\n\n\n\nvar Runtime = {\n  // FIXME backwards compatibility layer for ports. Support some Runtime.*\n  //       for now, fix it there, then remove it from here. That way we\n  //       can minimize any period of breakage.\n  dynCall: dynCall, // for SDL2 port\n};\n\n// The address globals begin at. Very low in memory, for code size and optimization opportunities.\n// Above 0 is static memory, starting with globals.\n// Then the stack.\n// Then 'dynamic' memory for sbrk.\nvar GLOBAL_BASE = 1024;\n\n\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n\n\n//========================================\n// Runtime essentials\n//========================================\n\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS = 0;\n\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed: ' + text);\n  }\n}\n\nvar globalScope = this;\n\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\nfunction getCFunc(ident) {\n  var func = Module['_' + ident]; // closure exported function\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n  return func;\n}\n\nvar JSfuncs = {\n  // Helpers for cwrap -- it can't refer to Runtime directly because it might\n  // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find\n  // out what the minified function name is.\n  'stackSave': function() {\n    stackSave()\n  },\n  'stackRestore': function() {\n    stackRestore()\n  },\n  // type conversion from js to c\n  'arrayToC' : function(arr) {\n    var ret = stackAlloc(arr.length);\n    writeArrayToMemory(arr, ret);\n    return ret;\n  },\n  'stringToC' : function(str) {\n    var ret = 0;\n    if (str !== null && str !== undefined && str !== 0) { // null string\n      // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n      var len = (str.length << 2) + 1;\n      ret = stackAlloc(len);\n      stringToUTF8(str, ret, len);\n    }\n    return ret;\n  }\n};\n\n// For fast lookup of conversion functions\nvar toC = {\n  'string': JSfuncs['stringToC'], 'array': JSfuncs['arrayToC']\n};\n\n\n// C calling interface.\nfunction ccall(ident, returnType, argTypes, args, opts) {\n  function convertReturnValue(ret) {\n    if (returnType === 'string') return Pointer_stringify(ret);\n    if (returnType === 'boolean') return Boolean(ret);\n    return ret;\n  }\n\n  var func = getCFunc(ident);\n  var cArgs = [];\n  var stack = 0;\n  if (args) {\n    for (var i = 0; i < args.length; i++) {\n      var converter = toC[argTypes[i]];\n      if (converter) {\n        if (stack === 0) stack = stackSave();\n        cArgs[i] = converter(args[i]);\n      } else {\n        cArgs[i] = args[i];\n      }\n    }\n  }\n  var ret = func.apply(null, cArgs);\n  ret = convertReturnValue(ret);\n  if (stack !== 0) stackRestore(stack);\n  return ret;\n}\n\nfunction cwrap(ident, returnType, argTypes, opts) {\n  argTypes = argTypes || [];\n  // When the function takes numbers and returns a number, we can just return\n  // the original function\n  var numericArgs = argTypes.every(function(type){ return type === 'number'});\n  var numericRet = returnType !== 'string';\n  if (numericRet && numericArgs && !opts) {\n    return getCFunc(ident);\n  }\n  return function() {\n    return ccall(ident, returnType, argTypes, arguments, opts);\n  }\n}\n\n/** @type {function(number, number, string, boolean=)} */\nfunction setValue(ptr, value, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': HEAP8[((ptr)>>0)]=value; break;\n      case 'i8': HEAP8[((ptr)>>0)]=value; break;\n      case 'i16': HEAP16[((ptr)>>1)]=value; break;\n      case 'i32': HEAP32[((ptr)>>2)]=value; break;\n      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;\n      case 'float': HEAPF32[((ptr)>>2)]=value; break;\n      case 'double': HEAPF64[((ptr)>>3)]=value; break;\n      default: abort('invalid type for setValue: ' + type);\n    }\n}\n\n/** @type {function(number, string, boolean=)} */\nfunction getValue(ptr, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': return HEAP8[((ptr)>>0)];\n      case 'i8': return HEAP8[((ptr)>>0)];\n      case 'i16': return HEAP16[((ptr)>>1)];\n      case 'i32': return HEAP32[((ptr)>>2)];\n      case 'i64': return HEAP32[((ptr)>>2)];\n      case 'float': return HEAPF32[((ptr)>>2)];\n      case 'double': return HEAPF64[((ptr)>>3)];\n      default: abort('invalid type for getValue: ' + type);\n    }\n  return null;\n}\n\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\nvar ALLOC_STATIC = 2; // Cannot be freed\nvar ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk\nvar ALLOC_NONE = 4; // Do not allocate\n\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\n//             is a little tricky (see docs right below). The reason is that it is optimized\n//             for multiple syntaxes to save space in generated code. So you should\n//             normally not use allocate(), and instead allocate memory using _malloc(),\n//             initialize it with setValue(), and so forth.\n// @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n//        in *bytes* (note that this is sometimes confusing: the next parameter does not\n//        affect this!)\n// @types: Either an array of types, one for each byte (or 0 if no type at that position),\n//         or a single type which is used for the entire block. This only matters if there\n//         is initial data - if @slab is a number, then this does not matter at all and is\n//         ignored.\n// @allocator: How to allocate memory, see ALLOC_*\n/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\nfunction allocate(slab, types, allocator, ptr) {\n  var zeroinit, size;\n  if (typeof slab === 'number') {\n    zeroinit = true;\n    size = slab;\n  } else {\n    zeroinit = false;\n    size = slab.length;\n  }\n\n  var singleType = typeof types === 'string' ? types : null;\n\n  var ret;\n  if (allocator == ALLOC_NONE) {\n    ret = ptr;\n  } else {\n    ret = [typeof _malloc === 'function' ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));\n  }\n\n  if (zeroinit) {\n    var stop;\n    ptr = ret;\n    assert((ret & 3) == 0);\n    stop = ret + (size & ~3);\n    for (; ptr < stop; ptr += 4) {\n      HEAP32[((ptr)>>2)]=0;\n    }\n    stop = ret + size;\n    while (ptr < stop) {\n      HEAP8[((ptr++)>>0)]=0;\n    }\n    return ret;\n  }\n\n  if (singleType === 'i8') {\n    if (slab.subarray || slab.slice) {\n      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);\n    } else {\n      HEAPU8.set(new Uint8Array(slab), ret);\n    }\n    return ret;\n  }\n\n  var i = 0, type, typeSize, previousType;\n  while (i < size) {\n    var curr = slab[i];\n\n    type = singleType || types[i];\n    if (type === 0) {\n      i++;\n      continue;\n    }\n\n    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n    setValue(ret+i, curr, type);\n\n    // no need to look up size unless type changes, so cache it\n    if (previousType !== type) {\n      typeSize = getNativeTypeSize(type);\n      previousType = type;\n    }\n    i += typeSize;\n  }\n\n  return ret;\n}\n\n// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\nfunction getMemory(size) {\n  if (!staticSealed) return staticAlloc(size);\n  if (!runtimeInitialized) return dynamicAlloc(size);\n  return _malloc(size);\n}\n\n/** @type {function(number, number=)} */\nfunction Pointer_stringify(ptr, length) {\n  if (length === 0 || !ptr) return '';\n  // Find the length, and check for UTF while doing so\n  var hasUtf = 0;\n  var t;\n  var i = 0;\n  while (1) {\n    t = HEAPU8[(((ptr)+(i))>>0)];\n    hasUtf |= t;\n    if (t == 0 && !length) break;\n    i++;\n    if (length && i == length) break;\n  }\n  if (!length) length = i;\n\n  var ret = '';\n\n  if (hasUtf < 128) {\n    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack\n    var curr;\n    while (length > 0) {\n      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\n      ret = ret ? ret + curr : curr;\n      ptr += MAX_CHUNK;\n      length -= MAX_CHUNK;\n    }\n    return ret;\n  }\n  return UTF8ToString(ptr);\n}\n\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction AsciiToString(ptr) {\n  var str = '';\n  while (1) {\n    var ch = HEAP8[((ptr++)>>0)];\n    if (!ch) return str;\n    str += String.fromCharCode(ch);\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\nfunction stringToAscii(str, outPtr) {\n  return writeAsciiToMemory(str, outPtr, false);\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\nfunction UTF8ArrayToString(u8Array, idx) {\n  var endPtr = idx;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  while (u8Array[endPtr]) ++endPtr;\n\n  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n  } else {\n    var u0, u1, u2, u3, u4, u5;\n\n    var str = '';\n    while (1) {\n      // For UTF8 byte structure, see:\n      // http://en.wikipedia.org/wiki/UTF-8#Description\n      // https://www.ietf.org/rfc/rfc2279.txt\n      // https://tools.ietf.org/html/rfc3629\n      u0 = u8Array[idx++];\n      if (!u0) return str;\n      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n      u1 = u8Array[idx++] & 63;\n      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n      u2 = u8Array[idx++] & 63;\n      if ((u0 & 0xF0) == 0xE0) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n      } else {\n        u3 = u8Array[idx++] & 63;\n        if ((u0 & 0xF8) == 0xF0) {\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\n        } else {\n          u4 = u8Array[idx++] & 63;\n          if ((u0 & 0xFC) == 0xF8) {\n            u0 = ((u0 & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;\n          } else {\n            u5 = u8Array[idx++] & 63;\n            u0 = ((u0 & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;\n          }\n        }\n      }\n      if (u0 < 0x10000) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 0x10000;\n        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n      }\n    }\n  }\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction UTF8ToString(ptr) {\n  return UTF8ArrayToString(HEAPU8,ptr);\n}\n\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n//                    This count should include the null terminator,\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n    return 0;\n\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) {\n      var u1 = str.charCodeAt(++i);\n      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\n    }\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      outU8Array[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      outU8Array[outIdx++] = 0xC0 | (u >> 6);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      outU8Array[outIdx++] = 0xE0 | (u >> 12);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0x1FFFFF) {\n      if (outIdx + 3 >= endIdx) break;\n      outU8Array[outIdx++] = 0xF0 | (u >> 18);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0x3FFFFFF) {\n      if (outIdx + 4 >= endIdx) break;\n      outU8Array[outIdx++] = 0xF8 | (u >> 24);\n      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else {\n      if (outIdx + 5 >= endIdx) break;\n      outU8Array[outIdx++] = 0xFC | (u >> 30);\n      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  outU8Array[outIdx] = 0;\n  return outIdx - startIdx;\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    if (u <= 0x7F) {\n      ++len;\n    } else if (u <= 0x7FF) {\n      len += 2;\n    } else if (u <= 0xFFFF) {\n      len += 3;\n    } else if (u <= 0x1FFFFF) {\n      len += 4;\n    } else if (u <= 0x3FFFFFF) {\n      len += 5;\n    } else {\n      len += 6;\n    }\n  }\n  return len;\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\nfunction UTF16ToString(ptr) {\n  var endPtr = ptr;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  var idx = endPtr >> 1;\n  while (HEAP16[idx]) ++idx;\n  endPtr = idx << 1;\n\n  if (endPtr - ptr > 32 && UTF16Decoder) {\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n  } else {\n    var i = 0;\n\n    var str = '';\n    while (1) {\n      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\n      if (codeUnit == 0) return str;\n      ++i;\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n      str += String.fromCharCode(codeUnit);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 2) return 0;\n  maxBytesToWrite -= 2; // Null terminator.\n  var startPtr = outPtr;\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\n  for (var i = 0; i < numCharsToWrite; ++i) {\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    HEAP16[((outPtr)>>1)]=codeUnit;\n    outPtr += 2;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP16[((outPtr)>>1)]=0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF16(str) {\n  return str.length*2;\n}\n\nfunction UTF32ToString(ptr) {\n  var i = 0;\n\n  var str = '';\n  while (1) {\n    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\n    if (utf32 == 0)\n      return str;\n    ++i;\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    if (utf32 >= 0x10000) {\n      var ch = utf32 - 0x10000;\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n    } else {\n      str += String.fromCharCode(utf32);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 4) return 0;\n  var startPtr = outPtr;\n  var endPtr = startPtr + maxBytesToWrite - 4;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n      var trailSurrogate = str.charCodeAt(++i);\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\n    }\n    HEAP32[((outPtr)>>2)]=codeUnit;\n    outPtr += 4;\n    if (outPtr + 4 > endPtr) break;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP32[((outPtr)>>2)]=0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF32(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i);\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n    len += 4;\n  }\n\n  return len;\n}\n\n// Allocate heap space for a JS string, and write it there.\n// It is the responsibility of the caller to free() that memory.\nfunction allocateUTF8(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = _malloc(size);\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\n// Allocate stack space for a JS string, and write it there.\nfunction allocateUTF8OnStack(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\nfunction demangle(func) {\n  return func;\n}\n\nfunction demangleAll(text) {\n  var regex =\n    /__Z[\\w\\d_]+/g;\n  return text.replace(regex,\n    function(x) {\n      var y = demangle(x);\n      return x === y ? x : (y + ' [' + x + ']');\n    });\n}\n\nfunction jsStackTrace() {\n  var err = new Error();\n  if (!err.stack) {\n    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n    // so try that as a special-case.\n    try {\n      throw new Error(0);\n    } catch(e) {\n      err = e;\n    }\n    if (!err.stack) {\n      return '(no stack trace available)';\n    }\n  }\n  return err.stack.toString();\n}\n\nfunction stackTrace() {\n  var js = jsStackTrace();\n  if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n  return demangleAll(js);\n}\n\n// Memory management\n\nvar PAGE_SIZE = 16384;\nvar WASM_PAGE_SIZE = 65536;\nvar ASMJS_PAGE_SIZE = 16777216;\nvar MIN_TOTAL_MEMORY = 16777216;\n\nfunction alignUp(x, multiple) {\n  if (x % multiple > 0) {\n    x += multiple - (x % multiple);\n  }\n  return x;\n}\n\nvar HEAP,\n/** @type {ArrayBuffer} */\n  buffer,\n/** @type {Int8Array} */\n  HEAP8,\n/** @type {Uint8Array} */\n  HEAPU8,\n/** @type {Int16Array} */\n  HEAP16,\n/** @type {Uint16Array} */\n  HEAPU16,\n/** @type {Int32Array} */\n  HEAP32,\n/** @type {Uint32Array} */\n  HEAPU32,\n/** @type {Float32Array} */\n  HEAPF32,\n/** @type {Float64Array} */\n  HEAPF64;\n\nfunction updateGlobalBuffer(buf) {\n  Module['buffer'] = buffer = buf;\n}\n\nfunction updateGlobalBufferViews() {\n  Module['HEAP8'] = HEAP8 = new Int8Array(buffer);\n  Module['HEAP16'] = HEAP16 = new Int16Array(buffer);\n  Module['HEAP32'] = HEAP32 = new Int32Array(buffer);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);\n}\n\nvar STATIC_BASE, STATICTOP, staticSealed; // static area\nvar STACK_BASE, STACKTOP, STACK_MAX; // stack area\nvar DYNAMIC_BASE, DYNAMICTOP_PTR; // dynamic area handled by sbrk\n\n  STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;\n  staticSealed = false;\n\n\n\n\nfunction abortOnCannotGrowMemory() {\n  abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n}\n\n\nfunction enlargeMemory() {\n  abortOnCannotGrowMemory();\n}\n\n\nvar TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;\nvar TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;\nif (TOTAL_MEMORY < TOTAL_STACK) err('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');\n\n// Initialize the runtime's memory\n\n\n\n// Use a provided buffer, if there is one, or else allocate a new one\nif (Module['buffer']) {\n  buffer = Module['buffer'];\n} else {\n  // Use a WebAssembly memory where available\n  if (typeof WebAssembly === 'object' && typeof WebAssembly.Memory === 'function') {\n    Module['wasmMemory'] = new WebAssembly.Memory({ 'initial': TOTAL_MEMORY / WASM_PAGE_SIZE, 'maximum': TOTAL_MEMORY / WASM_PAGE_SIZE });\n    buffer = Module['wasmMemory'].buffer;\n  } else\n  {\n    buffer = new ArrayBuffer(TOTAL_MEMORY);\n  }\n  Module['buffer'] = buffer;\n}\nupdateGlobalBufferViews();\n\n\nfunction getTotalMemory() {\n  return TOTAL_MEMORY;\n}\n\n// Endianness check (note: assumes compiler arch was little-endian)\n\nfunction callRuntimeCallbacks(callbacks) {\n  while(callbacks.length > 0) {\n    var callback = callbacks.shift();\n    if (typeof callback == 'function') {\n      callback();\n      continue;\n    }\n    var func = callback.func;\n    if (typeof func === 'number') {\n      if (callback.arg === undefined) {\n        Module['dynCall_v'](func);\n      } else {\n        Module['dynCall_vi'](func, callback.arg);\n      }\n    } else {\n      func(callback.arg === undefined ? null : callback.arg);\n    }\n  }\n}\n\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATMAIN__    = []; // functions called when main() is to be run\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\nvar runtimeExited = false;\n\n\nfunction preRun() {\n  // compatibility - merge in anything from Module['preRun'] at this time\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction ensureInitRuntime() {\n  if (runtimeInitialized) return;\n  runtimeInitialized = true;\n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n  callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction exitRuntime() {\n  callRuntimeCallbacks(__ATEXIT__);\n  runtimeExited = true;\n}\n\nfunction postRun() {\n  // compatibility - merge in anything from Module['postRun'] at this time\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnPreMain(cb) {\n  __ATMAIN__.unshift(cb);\n}\n\nfunction addOnExit(cb) {\n  __ATEXIT__.unshift(cb);\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\n// Deprecated: This function should not be called because it is unsafe and does not provide\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\n// to be secure from out of bounds writes.\n/** @deprecated */\nfunction writeStringToMemory(string, buffer, dontAddNull) {\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\n  if (dontAddNull) {\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\n    // character that existed at the location where the null will be placed, and restore\n    // that after the write (below).\n    end = buffer + lengthBytesUTF8(string);\n    lastChar = HEAP8[end];\n  }\n  stringToUTF8(string, buffer, Infinity);\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n}\n\nfunction writeArrayToMemory(array, buffer) {\n  HEAP8.set(array, buffer);\n}\n\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n  for (var i = 0; i < str.length; ++i) {\n    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);\n  }\n  // Null-terminate the pointer to the HEAP.\n  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;\n}\n\nfunction unSign(value, bits, ignore) {\n  if (value >= 0) {\n    return value;\n  }\n  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n                    : Math.pow(2, bits)         + value;\n}\nfunction reSign(value, bits, ignore) {\n  if (value <= 0) {\n    return value;\n  }\n  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32\n                        : Math.pow(2, bits-1);\n  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that\n                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n                                                       // TODO: In i64 mode 1, resign the two parts separately and safely\n    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n  }\n  return value;\n}\n\n\nvar Math_abs = Math.abs;\nvar Math_cos = Math.cos;\nvar Math_sin = Math.sin;\nvar Math_tan = Math.tan;\nvar Math_acos = Math.acos;\nvar Math_asin = Math.asin;\nvar Math_atan = Math.atan;\nvar Math_atan2 = Math.atan2;\nvar Math_exp = Math.exp;\nvar Math_log = Math.log;\nvar Math_sqrt = Math.sqrt;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_pow = Math.pow;\nvar Math_imul = Math.imul;\nvar Math_fround = Math.fround;\nvar Math_round = Math.round;\nvar Math_min = Math.min;\nvar Math_max = Math.max;\nvar Math_clz32 = Math.clz32;\nvar Math_trunc = Math.trunc;\n\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\nfunction getUniqueRunDependency(id) {\n  return id;\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\nModule[\"preloadedImages\"] = {}; // maps url to image data\nModule[\"preloadedAudios\"] = {}; // maps url to audio data\n\n\n\nvar memoryInitializer = null;\n\n\n\n\n\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\n\n// Indicates whether filename is a base64 data URI.\nfunction isDataURI(filename) {\n  return String.prototype.startsWith ?\n      filename.startsWith(dataURIPrefix) :\n      filename.indexOf(dataURIPrefix) === 0;\n}\n\n\n\n\nfunction integrateWasmJS() {\n  // wasm.js has several methods for creating the compiled code module here:\n  //  * 'native-wasm' : use native WebAssembly support in the browser\n  //  * 'interpret-s-expr': load s-expression code from a .wast and interpret\n  //  * 'interpret-binary': load binary wasm and interpret\n  //  * 'interpret-asm2wasm': load asm.js code, translate to wasm, and interpret\n  //  * 'asmjs': no wasm, just load the asm.js code and use that (good for testing)\n  // The method is set at compile time (BINARYEN_METHOD)\n  // The method can be a comma-separated list, in which case, we will try the\n  // options one by one. Some of them can fail gracefully, and then we can try\n  // the next.\n\n  // inputs\n\n  var method = 'native-wasm';\n\n  var wasmTextFile = 'fast-sound.wast';\n  var wasmBinaryFile = 'fast-sound.wasm';\n  var asmjsCodeFile = 'fast-sound.temp.asm.js';\n\n  if (!isDataURI(wasmTextFile)) {\n    wasmTextFile = locateFile(wasmTextFile);\n  }\n  if (!isDataURI(wasmBinaryFile)) {\n    wasmBinaryFile = locateFile(wasmBinaryFile);\n  }\n  if (!isDataURI(asmjsCodeFile)) {\n    asmjsCodeFile = locateFile(asmjsCodeFile);\n  }\n\n  // utilities\n\n  var wasmPageSize = 64*1024;\n\n  var info = {\n    'global': null,\n    'env': null,\n    'asm2wasm': asm2wasmImports,\n    'parent': Module // Module inside wasm-js.cpp refers to wasm-js.cpp; this allows access to the outside program.\n  };\n\n  var exports = null;\n\n\n  function mergeMemory(newBuffer) {\n    // The wasm instance creates its memory. But static init code might have written to\n    // buffer already, including the mem init file, and we must copy it over in a proper merge.\n    // TODO: avoid this copy, by avoiding such static init writes\n    // TODO: in shorter term, just copy up to the last static init write\n    var oldBuffer = Module['buffer'];\n    if (newBuffer.byteLength < oldBuffer.byteLength) {\n      err('the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here');\n    }\n    var oldView = new Int8Array(oldBuffer);\n    var newView = new Int8Array(newBuffer);\n\n\n    newView.set(oldView);\n    updateGlobalBuffer(newBuffer);\n    updateGlobalBufferViews();\n  }\n\n  function fixImports(imports) {\n    return imports;\n  }\n\n  function getBinary() {\n    try {\n      if (Module['wasmBinary']) {\n        return new Uint8Array(Module['wasmBinary']);\n      }\n      if (Module['readBinary']) {\n        return Module['readBinary'](wasmBinaryFile);\n      } else {\n        throw \"both async and sync fetching of the wasm failed\";\n      }\n    }\n    catch (err) {\n      abort(err);\n    }\n  }\n\n  function getBinaryPromise() {\n    // if we don't have the binary yet, and have the Fetch api, use that\n    // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n    if (!Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\n        if (!response['ok']) {\n          throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n        }\n        return response['arrayBuffer']();\n      }).catch(function () {\n        return getBinary();\n      });\n    }\n    // Otherwise, getBinary should be able to get it synchronously\n    return new Promise(function(resolve, reject) {\n      resolve(getBinary());\n    });\n  }\n\n  // do-method functions\n\n\n  function doNativeWasm(global, env, providedBuffer) {\n    if (typeof WebAssembly !== 'object') {\n      err('no native wasm support detected');\n      return false;\n    }\n    // prepare memory import\n    if (!(Module['wasmMemory'] instanceof WebAssembly.Memory)) {\n      err('no native wasm Memory in use');\n      return false;\n    }\n    env['memory'] = Module['wasmMemory'];\n    // Load the wasm module and create an instance of using native support in the JS engine.\n    info['global'] = {\n      'NaN': NaN,\n      'Infinity': Infinity\n    };\n    info['global.Math'] = Math;\n    info['env'] = env;\n    // handle a generated wasm instance, receiving its exports and\n    // performing other necessary setup\n    function receiveInstance(instance, module) {\n      exports = instance.exports;\n      if (exports.memory) mergeMemory(exports.memory);\n      Module['asm'] = exports;\n      Module[\"usingWasm\"] = true;\n      removeRunDependency('wasm-instantiate');\n    }\n    addRunDependency('wasm-instantiate');\n\n    // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n    // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n    // to any other async startup actions they are performing.\n    if (Module['instantiateWasm']) {\n      try {\n        return Module['instantiateWasm'](info, receiveInstance);\n      } catch(e) {\n        err('Module.instantiateWasm callback failed with error: ' + e);\n        return false;\n      }\n    }\n\n    function receiveInstantiatedSource(output) {\n      // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n      // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n      receiveInstance(output['instance'], output['module']);\n    }\n    function instantiateArrayBuffer(receiver) {\n      getBinaryPromise().then(function(binary) {\n        return WebAssembly.instantiate(binary, info);\n      }).then(receiver, function(reason) {\n        err('failed to asynchronously prepare wasm: ' + reason);\n        abort(reason);\n      });\n    }\n    // Prefer streaming instantiation if available.\n    if (!Module['wasmBinary'] &&\n        typeof WebAssembly.instantiateStreaming === 'function' &&\n        !isDataURI(wasmBinaryFile) &&\n        typeof fetch === 'function') {\n      WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, { credentials: 'same-origin' }), info)\n        .then(receiveInstantiatedSource, function(reason) {\n          // We expect the most common failure cause to be a bad MIME type for the binary,\n          // in which case falling back to ArrayBuffer instantiation should work.\n          err('wasm streaming compile failed: ' + reason);\n          err('falling back to ArrayBuffer instantiation');\n          instantiateArrayBuffer(receiveInstantiatedSource);\n        });\n    } else {\n      instantiateArrayBuffer(receiveInstantiatedSource);\n    }\n    return {}; // no exports yet; we'll fill them in later\n  }\n\n\n  // We may have a preloaded value in Module.asm, save it\n  Module['asmPreload'] = Module['asm'];\n\n  // Memory growth integration code\n\n  var asmjsReallocBuffer = Module['reallocBuffer'];\n\n  var wasmReallocBuffer = function(size) {\n    var PAGE_MULTIPLE = Module[\"usingWasm\"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE; // In wasm, heap size must be a multiple of 64KB. In asm.js, they need to be multiples of 16MB.\n    size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size\n    var old = Module['buffer'];\n    var oldSize = old.byteLength;\n    if (Module[\"usingWasm\"]) {\n      // native wasm support\n      try {\n        var result = Module['wasmMemory'].grow((size - oldSize) / wasmPageSize); // .grow() takes a delta compared to the previous size\n        if (result !== (-1 | 0)) {\n          // success in native wasm memory growth, get the buffer from the memory\n          return Module['buffer'] = Module['wasmMemory'].buffer;\n        } else {\n          return null;\n        }\n      } catch(e) {\n        return null;\n      }\n    }\n  };\n\n  Module['reallocBuffer'] = function(size) {\n    if (finalMethod === 'asmjs') {\n      return asmjsReallocBuffer(size);\n    } else {\n      return wasmReallocBuffer(size);\n    }\n  };\n\n  // we may try more than one; this is the final one, that worked and we are using\n  var finalMethod = '';\n\n  // Provide an \"asm.js function\" for the application, called to \"link\" the asm.js module. We instantiate\n  // the wasm module at that time, and it receives imports and provides exports and so forth, the app\n  // doesn't need to care that it is wasm or olyfilled wasm or asm.js.\n\n  Module['asm'] = function(global, env, providedBuffer) {\n    env = fixImports(env);\n\n    // import table\n    if (!env['table']) {\n      var TABLE_SIZE = Module['wasmTableSize'];\n      if (TABLE_SIZE === undefined) TABLE_SIZE = 1024; // works in binaryen interpreter at least\n      var MAX_TABLE_SIZE = Module['wasmMaxTableSize'];\n      if (typeof WebAssembly === 'object' && typeof WebAssembly.Table === 'function') {\n        if (MAX_TABLE_SIZE !== undefined) {\n          env['table'] = new WebAssembly.Table({ 'initial': TABLE_SIZE, 'maximum': MAX_TABLE_SIZE, 'element': 'anyfunc' });\n        } else {\n          env['table'] = new WebAssembly.Table({ 'initial': TABLE_SIZE, element: 'anyfunc' });\n        }\n      } else {\n        env['table'] = new Array(TABLE_SIZE); // works in binaryen interpreter at least\n      }\n      Module['wasmTable'] = env['table'];\n    }\n\n    if (!env['memoryBase']) {\n      env['memoryBase'] = Module['STATIC_BASE']; // tell the memory segments where to place themselves\n    }\n    if (!env['tableBase']) {\n      env['tableBase'] = 0; // table starts at 0 by default, in dynamic linking this will change\n    }\n\n    // try the methods. each should return the exports if it succeeded\n\n    var exports;\n    exports = doNativeWasm(global, env, providedBuffer);\n\n    assert(exports, 'no binaryen method succeeded.');\n\n\n    return exports;\n  };\n\n  var methodHandler = Module['asm']; // note our method handler, as we may modify Module['asm'] later\n}\n\nintegrateWasmJS();\n\n// === Body ===\n\nvar ASM_CONSTS = [];\n\n\n\n\n\nSTATIC_BASE = GLOBAL_BASE;\n\nSTATICTOP = STATIC_BASE + 52064;\n/* global initializers */  __ATINIT__.push();\n\n\n\n\n\n\n\nvar STATIC_BUMP = 52064;\nModule[\"STATIC_BASE\"] = STATIC_BASE;\nModule[\"STATIC_BUMP\"] = STATIC_BUMP;\n\n/* no memory initializer */\nvar tempDoublePtr = STATICTOP; STATICTOP += 16;\n\nfunction copyTempFloat(ptr) { // functions, because inlining this code increases code size too much\n\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\n\n  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\n\n  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\n\n  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\n\n}\n\nfunction copyTempDouble(ptr) {\n\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\n\n  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\n\n  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\n\n  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\n\n  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];\n\n  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];\n\n  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];\n\n  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];\n\n}\n\n// {{PRE_LIBRARY}}\n\n\n  \n  var SYSCALLS={varargs:0,get:function (varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\n        return ret;\n      },getStr:function () {\n        var ret = Pointer_stringify(SYSCALLS.get());\n        return ret;\n      },get64:function () {\n        var low = SYSCALLS.get(), high = SYSCALLS.get();\n        if (low >= 0) assert(high === 0);\n        else assert(high === -1);\n        return low;\n      },getZero:function () {\n        assert(SYSCALLS.get() === 0);\n      }};function ___syscall140(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // llseek\n      var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();\n      // NOTE: offset_high is unused - Emscripten's off_t is 32-bit\n      var offset = offset_low;\n      FS.llseek(stream, offset, whence);\n      HEAP32[((result)>>2)]=stream.position;\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  \n  function flush_NO_FILESYSTEM() {\n      // flush anything remaining in the buffers during shutdown\n      var fflush = Module[\"_fflush\"];\n      if (fflush) fflush(0);\n      var printChar = ___syscall146.printChar;\n      if (!printChar) return;\n      var buffers = ___syscall146.buffers;\n      if (buffers[1].length) printChar(1, 10);\n      if (buffers[2].length) printChar(2, 10);\n    }function ___syscall146(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // writev\n      // hack to support printf in FILESYSTEM=0\n      var stream = SYSCALLS.get(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();\n      var ret = 0;\n      if (!___syscall146.buffers) {\n        ___syscall146.buffers = [null, [], []]; // 1 => stdout, 2 => stderr\n        ___syscall146.printChar = function(stream, curr) {\n          var buffer = ___syscall146.buffers[stream];\n          assert(buffer);\n          if (curr === 0 || curr === 10) {\n            (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n            buffer.length = 0;\n          } else {\n            buffer.push(curr);\n          }\n        };\n      }\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAP32[(((iov)+(i*8))>>2)];\n        var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\n        for (var j = 0; j < len; j++) {\n          ___syscall146.printChar(stream, HEAPU8[ptr+j]);\n        }\n        ret += len;\n      }\n      return ret;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall6(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // close\n      var stream = SYSCALLS.getStreamFromFD();\n      FS.close(stream);\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function _abort() {\n      Module['abort']();\n    }\n\n   \n\n  var _llvm_cos_f64=Math_cos;\n\n  var _llvm_ctlz_i32=true;\n\n  \n  function _llvm_exp2_f32(x) {\n      return Math.pow(2, x);\n    }function _llvm_exp2_f64() {\n  return _llvm_exp2_f32.apply(null, arguments)\n  }\n\n  var _llvm_exp_f64=Math_exp;\n\n  var _llvm_fabs_f32=Math_abs;\n\n  var _llvm_floor_f32=Math_floor;\n\n  var _llvm_floor_f64=Math_floor;\n\n  \n  function _llvm_log10_f32(x) {\n      return Math.log(x) / Math.LN10; // TODO: Math.log10, when browser support is there\n    }function _llvm_log10_f64() {\n  return _llvm_log10_f32.apply(null, arguments)\n  }\n\n  var _llvm_log_f64=Math_log;\n\n  var _llvm_sin_f64=Math_sin;\n\n  var _llvm_sqrt_f32=Math_sqrt;\n\n  var _llvm_sqrt_f64=Math_sqrt;\n\n  function _llvm_stackrestore(p) {\n      var self = _llvm_stacksave;\n      var ret = self.LLVM_SAVEDSTACKS[p];\n      self.LLVM_SAVEDSTACKS.splice(p, 1);\n      stackRestore(ret);\n    }\n\n  function _llvm_stacksave() {\n      var self = _llvm_stacksave;\n      if (!self.LLVM_SAVEDSTACKS) {\n        self.LLVM_SAVEDSTACKS = [];\n      }\n      self.LLVM_SAVEDSTACKS.push(stackSave());\n      return self.LLVM_SAVEDSTACKS.length-1;\n    }\n\n  \n  function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);\n      return dest;\n    } \n\n   \n\n   \n\n  \n    \n\n  \n  function ___setErrNo(value) {\n      if (Module['___errno_location']) HEAP32[((Module['___errno_location']())>>2)]=value;\n      return value;\n    } \nDYNAMICTOP_PTR = staticAlloc(4);\n\nSTACK_BASE = STACKTOP = alignMemory(STATICTOP);\n\nSTACK_MAX = STACK_BASE + TOTAL_STACK;\n\nDYNAMIC_BASE = alignMemory(STACK_MAX);\n\nHEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;\n\nstaticSealed = true; // seal the static portion of memory\n\nvar ASSERTIONS = false;\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n/** @type {function(string, boolean=, number=)} */\nfunction intArrayFromString(stringy, dontAddNull, length) {\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\n  var u8array = new Array(len);\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n  if (dontAddNull) u8array.length = numBytesWritten;\n  return u8array;\n}\n\nfunction intArrayToString(array) {\n  var ret = [];\n  for (var i = 0; i < array.length; i++) {\n    var chr = array[i];\n    if (chr > 0xFF) {\n      if (ASSERTIONS) {\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n      }\n      chr &= 0xFF;\n    }\n    ret.push(String.fromCharCode(chr));\n  }\n  return ret.join('');\n}\n\n\n\nModule['wasmTableSize'] = 16;\n\nModule['wasmMaxTableSize'] = 16;\n\nfunction invoke_ii(index,a1) {\n  var sp = stackSave();\n  try {\n    return Module[\"dynCall_ii\"](index,a1);\n  } catch(e) {\n    stackRestore(sp);\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_iiii(index,a1,a2,a3) {\n  var sp = stackSave();\n  try {\n    return Module[\"dynCall_iiii\"](index,a1,a2,a3);\n  } catch(e) {\n    stackRestore(sp);\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6) {\n  var sp = stackSave();\n  try {\n    return Module[\"dynCall_iiiiiii\"](index,a1,a2,a3,a4,a5,a6);\n  } catch(e) {\n    stackRestore(sp);\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {\n  var sp = stackSave();\n  try {\n    Module[\"dynCall_viiiiiii\"](index,a1,a2,a3,a4,a5,a6,a7);\n  } catch(e) {\n    stackRestore(sp);\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nModule.asmGlobalArg = {};\n\nModule.asmLibraryArg = { \"abort\": abort, \"assert\": assert, \"enlargeMemory\": enlargeMemory, \"getTotalMemory\": getTotalMemory, \"abortOnCannotGrowMemory\": abortOnCannotGrowMemory, \"invoke_ii\": invoke_ii, \"invoke_iiii\": invoke_iiii, \"invoke_iiiiiii\": invoke_iiiiiii, \"invoke_viiiiiii\": invoke_viiiiiii, \"___setErrNo\": ___setErrNo, \"___syscall140\": ___syscall140, \"___syscall146\": ___syscall146, \"___syscall6\": ___syscall6, \"_abort\": _abort, \"_emscripten_memcpy_big\": _emscripten_memcpy_big, \"_llvm_cos_f64\": _llvm_cos_f64, \"_llvm_exp2_f32\": _llvm_exp2_f32, \"_llvm_exp2_f64\": _llvm_exp2_f64, \"_llvm_exp_f64\": _llvm_exp_f64, \"_llvm_fabs_f32\": _llvm_fabs_f32, \"_llvm_floor_f32\": _llvm_floor_f32, \"_llvm_floor_f64\": _llvm_floor_f64, \"_llvm_log10_f32\": _llvm_log10_f32, \"_llvm_log10_f64\": _llvm_log10_f64, \"_llvm_log_f64\": _llvm_log_f64, \"_llvm_sin_f64\": _llvm_sin_f64, \"_llvm_sqrt_f32\": _llvm_sqrt_f32, \"_llvm_sqrt_f64\": _llvm_sqrt_f64, \"_llvm_stackrestore\": _llvm_stackrestore, \"_llvm_stacksave\": _llvm_stacksave, \"flush_NO_FILESYSTEM\": flush_NO_FILESYSTEM, \"DYNAMICTOP_PTR\": DYNAMICTOP_PTR, \"tempDoublePtr\": tempDoublePtr, \"STACKTOP\": STACKTOP, \"STACK_MAX\": STACK_MAX };\n// EMSCRIPTEN_START_ASM\nvar asm =Module[\"asm\"]// EMSCRIPTEN_END_ASM\n(Module.asmGlobalArg, Module.asmLibraryArg, buffer);\n\nModule[\"asm\"] = asm;\nvar _free = Module[\"_free\"] = function() {  return Module[\"asm\"][\"_free\"].apply(null, arguments) };\nvar _llvm_bswap_i32 = Module[\"_llvm_bswap_i32\"] = function() {  return Module[\"asm\"][\"_llvm_bswap_i32\"].apply(null, arguments) };\nvar _malloc = Module[\"_malloc\"] = function() {  return Module[\"asm\"][\"_malloc\"].apply(null, arguments) };\nvar _memcpy = Module[\"_memcpy\"] = function() {  return Module[\"asm\"][\"_memcpy\"].apply(null, arguments) };\nvar _memmove = Module[\"_memmove\"] = function() {  return Module[\"asm\"][\"_memmove\"].apply(null, arguments) };\nvar _memset = Module[\"_memset\"] = function() {  return Module[\"asm\"][\"_memset\"].apply(null, arguments) };\nvar _opus_decode_float = Module[\"_opus_decode_float\"] = function() {  return Module[\"asm\"][\"_opus_decode_float\"].apply(null, arguments) };\nvar _opus_decoder_create = Module[\"_opus_decoder_create\"] = function() {  return Module[\"asm\"][\"_opus_decoder_create\"].apply(null, arguments) };\nvar _opus_decoder_destroy = Module[\"_opus_decoder_destroy\"] = function() {  return Module[\"asm\"][\"_opus_decoder_destroy\"].apply(null, arguments) };\nvar _opus_encode_float = Module[\"_opus_encode_float\"] = function() {  return Module[\"asm\"][\"_opus_encode_float\"].apply(null, arguments) };\nvar _opus_encoder_create = Module[\"_opus_encoder_create\"] = function() {  return Module[\"asm\"][\"_opus_encoder_create\"].apply(null, arguments) };\nvar _opus_encoder_ctl = Module[\"_opus_encoder_ctl\"] = function() {  return Module[\"asm\"][\"_opus_encoder_ctl\"].apply(null, arguments) };\nvar _rintf = Module[\"_rintf\"] = function() {  return Module[\"asm\"][\"_rintf\"].apply(null, arguments) };\nvar _sbrk = Module[\"_sbrk\"] = function() {  return Module[\"asm\"][\"_sbrk\"].apply(null, arguments) };\nvar _speex_resampler_destroy = Module[\"_speex_resampler_destroy\"] = function() {  return Module[\"asm\"][\"_speex_resampler_destroy\"].apply(null, arguments) };\nvar _speex_resampler_init = Module[\"_speex_resampler_init\"] = function() {  return Module[\"asm\"][\"_speex_resampler_init\"].apply(null, arguments) };\nvar _speex_resampler_process_interleaved_float = Module[\"_speex_resampler_process_interleaved_float\"] = function() {  return Module[\"asm\"][\"_speex_resampler_process_interleaved_float\"].apply(null, arguments) };\nvar establishStackSpace = Module[\"establishStackSpace\"] = function() {  return Module[\"asm\"][\"establishStackSpace\"].apply(null, arguments) };\nvar getTempRet0 = Module[\"getTempRet0\"] = function() {  return Module[\"asm\"][\"getTempRet0\"].apply(null, arguments) };\nvar runPostSets = Module[\"runPostSets\"] = function() {  return Module[\"asm\"][\"runPostSets\"].apply(null, arguments) };\nvar setTempRet0 = Module[\"setTempRet0\"] = function() {  return Module[\"asm\"][\"setTempRet0\"].apply(null, arguments) };\nvar setThrew = Module[\"setThrew\"] = function() {  return Module[\"asm\"][\"setThrew\"].apply(null, arguments) };\nvar stackAlloc = Module[\"stackAlloc\"] = function() {  return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments) };\nvar stackRestore = Module[\"stackRestore\"] = function() {  return Module[\"asm\"][\"stackRestore\"].apply(null, arguments) };\nvar stackSave = Module[\"stackSave\"] = function() {  return Module[\"asm\"][\"stackSave\"].apply(null, arguments) };\nvar dynCall_ii = Module[\"dynCall_ii\"] = function() {  return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments) };\nvar dynCall_iiii = Module[\"dynCall_iiii\"] = function() {  return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments) };\nvar dynCall_iiiiiii = Module[\"dynCall_iiiiiii\"] = function() {  return Module[\"asm\"][\"dynCall_iiiiiii\"].apply(null, arguments) };\nvar dynCall_viiiiiii = Module[\"dynCall_viiiiiii\"] = function() {  return Module[\"asm\"][\"dynCall_viiiiiii\"].apply(null, arguments) };\n;\n\n\n\n// === Auto-generated postamble setup entry stuff ===\n\nModule['asm'] = asm;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Modularize mode returns a function, which can be called to\n// create instances. The instances provide a then() method,\n// must like a Promise, that receives a callback. The callback\n// is called when the module is ready to run, with the module\n// as a parameter. (Like a Promise, it also returns the module\n// so you can use the output of .then(..)).\nModule['then'] = function(func) {\n  // We may already be ready to run code at this time. if\n  // so, just queue a call to the callback.\n  if (Module['calledRun']) {\n    func(Module);\n  } else {\n    // we are not ready to call then() yet. we must call it\n    // at the same time we would call onRuntimeInitialized.\n    var old = Module['onRuntimeInitialized'];\n    Module['onRuntimeInitialized'] = function() {\n      if (old) old();\n      func(Module);\n    };\n  }\n  return Module;\n};\n\n/**\n * @constructor\n * @extends {Error}\n * @this {ExitStatus}\n */\nfunction ExitStatus(status) {\n  this.name = \"ExitStatus\";\n  this.message = \"Program terminated with exit(\" + status + \")\";\n  this.status = status;\n};\nExitStatus.prototype = new Error();\nExitStatus.prototype.constructor = ExitStatus;\n\nvar initialStackTop;\nvar calledMain = false;\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!Module['calledRun']) run();\n  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n}\n\n\n\n\n\n/** @type {function(Array=)} */\nfunction run(args) {\n  args = args || Module['arguments'];\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n\n  preRun();\n\n  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame\n\n  function doRun() {\n    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening\n    Module['calledRun'] = true;\n\n    if (ABORT) return;\n\n    ensureInitRuntime();\n\n    preMain();\n\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function() {\n      setTimeout(function() {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else {\n    doRun();\n  }\n}\nModule['run'] = run;\n\n\nfunction exit(status, implicit) {\n\n  // if this is just main exit-ing implicitly, and the status is 0, then we\n  // don't need to do anything here and can just leave. if the status is\n  // non-zero, though, then we need to report it.\n  // (we may have warned about this earlier, if a situation justifies doing so)\n  if (implicit && Module['noExitRuntime'] && status === 0) {\n    return;\n  }\n\n  if (Module['noExitRuntime']) {\n  } else {\n\n    ABORT = true;\n    EXITSTATUS = status;\n    STACKTOP = initialStackTop;\n\n    exitRuntime();\n\n    if (Module['onExit']) Module['onExit'](status);\n  }\n\n  Module['quit'](status, new ExitStatus(status));\n}\n\nvar abortDecorators = [];\n\nfunction abort(what) {\n  if (Module['onAbort']) {\n    Module['onAbort'](what);\n  }\n\n  if (what !== undefined) {\n    out(what);\n    err(what);\n    what = JSON.stringify(what)\n  } else {\n    what = '';\n  }\n\n  ABORT = true;\n  EXITSTATUS = 1;\n\n  throw 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.';\n}\nModule['abort'] = abort;\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\n\n\nModule[\"noExitRuntime\"] = true;\n\nrun();\n\n\n\n\n\n// {{MODULE_ADDITIONS}}\n\n\n\n\n\n  return FastSound;\n}\n);\n})();\nif (true)\n    module.exports = FastSound;\n  else {}\n  \n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91bm1pbmlmaWVkL2Zhc3Qtc291bmQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9GYXN0U291bmQvLi91bm1pbmlmaWVkL2Zhc3Qtc291bmQuanM/M2U5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBGYXN0U291bmQgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBfc2NyaXB0RGlyID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0ID8gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMgOiB1bmRlZmluZWQ7XG4gIHJldHVybiAoXG5mdW5jdGlvbihGYXN0U291bmQpIHtcbiAgRmFzdFNvdW5kID0gRmFzdFNvdW5kIHx8IHt9O1xuXG4vLyBDb3B5cmlnaHQgMjAxMCBUaGUgRW1zY3JpcHRlbiBBdXRob3JzLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIEVtc2NyaXB0ZW4gaXMgYXZhaWxhYmxlIHVuZGVyIHR3byBzZXBhcmF0ZSBsaWNlbnNlcywgdGhlIE1JVCBsaWNlbnNlIGFuZCB0aGVcbi8vIFVuaXZlcnNpdHkgb2YgSWxsaW5vaXMvTkNTQSBPcGVuIFNvdXJjZSBMaWNlbnNlLiAgQm90aCB0aGVzZSBsaWNlbnNlcyBjYW4gYmVcbi8vIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG5cbi8vIFRoZSBNb2R1bGUgb2JqZWN0OiBPdXIgaW50ZXJmYWNlIHRvIHRoZSBvdXRzaWRlIHdvcmxkLiBXZSBpbXBvcnRcbi8vIGFuZCBleHBvcnQgdmFsdWVzIG9uIGl0LiBUaGVyZSBhcmUgdmFyaW91cyB3YXlzIE1vZHVsZSBjYW4gYmUgdXNlZDpcbi8vIDEuIE5vdCBkZWZpbmVkLiBXZSBjcmVhdGUgaXQgaGVyZVxuLy8gMi4gQSBmdW5jdGlvbiBwYXJhbWV0ZXIsIGZ1bmN0aW9uKE1vZHVsZSkgeyAuLmdlbmVyYXRlZCBjb2RlLi4gfVxuLy8gMy4gcHJlLXJ1biBhcHBlbmRlZCBpdCwgdmFyIE1vZHVsZSA9IHt9OyAuLmdlbmVyYXRlZCBjb2RlLi5cbi8vIDQuIEV4dGVybmFsIHNjcmlwdCB0YWcgZGVmaW5lcyB2YXIgTW9kdWxlLlxuLy8gV2UgbmVlZCB0byBjaGVjayBpZiBNb2R1bGUgYWxyZWFkeSBleGlzdHMgKGUuZy4gY2FzZSAzIGFib3ZlKS5cbi8vIFN1YnN0aXR1dGlvbiB3aWxsIGJlIHJlcGxhY2VkIHdpdGggYWN0dWFsIGNvZGUgb24gbGF0ZXIgc3RhZ2Ugb2YgdGhlIGJ1aWxkLFxuLy8gdGhpcyB3YXkgQ2xvc3VyZSBDb21waWxlciB3aWxsIG5vdCBtYW5nbGUgaXQgKGUuZy4gY2FzZSA0LiBhYm92ZSkuXG4vLyBOb3RlIHRoYXQgaWYgeW91IHdhbnQgdG8gcnVuIGNsb3N1cmUsIGFuZCBhbHNvIHRvIHVzZSBNb2R1bGVcbi8vIGFmdGVyIHRoZSBnZW5lcmF0ZWQgY29kZSwgeW91IHdpbGwgbmVlZCB0byBkZWZpbmUgICB2YXIgTW9kdWxlID0ge307XG4vLyBiZWZvcmUgdGhlIGNvZGUuIFRoZW4gdGhhdCBvYmplY3Qgd2lsbCBiZSB1c2VkIGluIHRoZSBjb2RlLCBhbmQgeW91XG4vLyBjYW4gY29udGludWUgdG8gdXNlIE1vZHVsZSBhZnRlcndhcmRzIGFzIHdlbGwuXG52YXIgTW9kdWxlID0gdHlwZW9mIEZhc3RTb3VuZCAhPT0gJ3VuZGVmaW5lZCcgPyBGYXN0U291bmQgOiB7fTtcblxuLy8gLS1wcmUtanNlcyBhcmUgZW1pdHRlZCBhZnRlciB0aGUgTW9kdWxlIGludGVncmF0aW9uIGNvZGUsIHNvIHRoYXQgdGhleSBjYW5cbi8vIHJlZmVyIHRvIE1vZHVsZSAoaWYgdGhleSBjaG9vc2U7IHRoZXkgY2FuIGFsc28gZGVmaW5lIE1vZHVsZSlcbi8vIHt7UFJFX0pTRVN9fVxuXG4vLyBTb21ldGltZXMgYW4gZXhpc3RpbmcgTW9kdWxlIG9iamVjdCBleGlzdHMgd2l0aCBwcm9wZXJ0aWVzXG4vLyBtZWFudCB0byBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgbW9kdWxlIGZ1bmN0aW9uYWxpdHkuIEhlcmVcbi8vIHdlIGNvbGxlY3QgdGhvc2UgcHJvcGVydGllcyBhbmQgcmVhcHBseSBfYWZ0ZXJfIHdlIGNvbmZpZ3VyZVxuLy8gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBkZWZhdWx0cyB0byBhdm9pZCBoYXZpbmcgdG8gYmUgc29cbi8vIGRlZmVuc2l2ZSBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG52YXIgbW9kdWxlT3ZlcnJpZGVzID0ge307XG52YXIga2V5O1xuZm9yIChrZXkgaW4gTW9kdWxlKSB7XG4gIGlmIChNb2R1bGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIG1vZHVsZU92ZXJyaWRlc1trZXldID0gTW9kdWxlW2tleV07XG4gIH1cbn1cblxuTW9kdWxlWydhcmd1bWVudHMnXSA9IFtdO1xuTW9kdWxlWyd0aGlzUHJvZ3JhbSddID0gJy4vdGhpcy5wcm9ncmFtJztcbk1vZHVsZVsncXVpdCddID0gZnVuY3Rpb24oc3RhdHVzLCB0b1Rocm93KSB7XG4gIHRocm93IHRvVGhyb3c7XG59O1xuTW9kdWxlWydwcmVSdW4nXSA9IFtdO1xuTW9kdWxlWydwb3N0UnVuJ10gPSBbXTtcblxuLy8gRGV0ZXJtaW5lIHRoZSBydW50aW1lIGVudmlyb25tZW50IHdlIGFyZSBpbi4gWW91IGNhbiBjdXN0b21pemUgdGhpcyBieVxuLy8gc2V0dGluZyB0aGUgRU5WSVJPTk1FTlQgc2V0dGluZyBhdCBjb21waWxlIHRpbWUgKHNlZSBzZXR0aW5ncy5qcykuXG5cbnZhciBFTlZJUk9OTUVOVF9JU19XRUIgPSBmYWxzZTtcbnZhciBFTlZJUk9OTUVOVF9JU19XT1JLRVIgPSBmYWxzZTtcbnZhciBFTlZJUk9OTUVOVF9JU19OT0RFID0gZmFsc2U7XG52YXIgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPSBmYWxzZTtcbkVOVklST05NRU5UX0lTX1dFQiA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnO1xuRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gdHlwZW9mIGltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbic7XG5FTlZJUk9OTUVOVF9JU19OT0RFID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nICYmICFFTlZJUk9OTUVOVF9JU19XRUIgJiYgIUVOVklST05NRU5UX0lTX1dPUktFUjtcbkVOVklST05NRU5UX0lTX1NIRUxMID0gIUVOVklST05NRU5UX0lTX1dFQiAmJiAhRU5WSVJPTk1FTlRfSVNfTk9ERSAmJiAhRU5WSVJPTk1FTlRfSVNfV09SS0VSO1xuXG5cbi8vIFRocmVlIGNvbmZpZ3VyYXRpb25zIHdlIGNhbiBiZSBydW5uaW5nIGluOlxuLy8gMSkgV2UgY291bGQgYmUgdGhlIGFwcGxpY2F0aW9uIG1haW4oKSB0aHJlYWQgcnVubmluZyBpbiB0aGUgbWFpbiBKUyBVSSB0aHJlYWQuIChFTlZJUk9OTUVOVF9JU19XT1JLRVIgPT0gZmFsc2UgYW5kIEVOVklST05NRU5UX0lTX1BUSFJFQUQgPT0gZmFsc2UpXG4vLyAyKSBXZSBjb3VsZCBiZSB0aGUgYXBwbGljYXRpb24gbWFpbigpIHRocmVhZCBwcm94aWVkIHRvIHdvcmtlci4gKHdpdGggRW1zY3JpcHRlbiAtcyBQUk9YWV9UT19XT1JLRVI9MSkgKEVOVklST05NRU5UX0lTX1dPUktFUiA9PSB0cnVlLCBFTlZJUk9OTUVOVF9JU19QVEhSRUFEID09IGZhbHNlKVxuLy8gMykgV2UgY291bGQgYmUgYW4gYXBwbGljYXRpb24gcHRocmVhZCBydW5uaW5nIGluIGEgd29ya2VyLiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSID09IHRydWUgYW5kIEVOVklST05NRU5UX0lTX1BUSFJFQUQgPT0gdHJ1ZSlcblxuXG4vLyBgL2Agc2hvdWxkIGJlIHByZXNlbnQgYXQgdGhlIGVuZCBpZiBgc2NyaXB0RGlyZWN0b3J5YCBpcyBub3QgZW1wdHlcbnZhciBzY3JpcHREaXJlY3RvcnkgPSAnJztcbmZ1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCkge1xuICBpZiAoTW9kdWxlWydsb2NhdGVGaWxlJ10pIHtcbiAgICByZXR1cm4gTW9kdWxlWydsb2NhdGVGaWxlJ10ocGF0aCwgc2NyaXB0RGlyZWN0b3J5KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2NyaXB0RGlyZWN0b3J5ICsgcGF0aDtcbiAgfVxufVxuXG5pZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuICBzY3JpcHREaXJlY3RvcnkgPSBfX2Rpcm5hbWUgKyAnLyc7XG5cbiAgLy8gRXhwb3NlIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIHNhbWUgc2ltcGxlIHdheSB0aGF0IHRoZSBzaGVsbHMgd29ya1xuICAvLyBOb3RlIHRoYXQgd2UgcG9sbHV0ZSB0aGUgZ2xvYmFsIG5hbWVzcGFjZSBoZXJlLCBvdGhlcndpc2Ugd2UgYnJlYWsgaW4gbm9kZVxuICB2YXIgbm9kZUZTO1xuICB2YXIgbm9kZVBhdGg7XG5cbiAgTW9kdWxlWydyZWFkJ10gPSBmdW5jdGlvbiBzaGVsbF9yZWFkKGZpbGVuYW1lLCBiaW5hcnkpIHtcbiAgICB2YXIgcmV0O1xuICAgICAgaWYgKCFub2RlRlMpIG5vZGVGUyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgICBpZiAoIW5vZGVQYXRoKSBub2RlUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbiAgICAgIGZpbGVuYW1lID0gbm9kZVBhdGhbJ25vcm1hbGl6ZSddKGZpbGVuYW1lKTtcbiAgICAgIHJldCA9IG5vZGVGU1sncmVhZEZpbGVTeW5jJ10oZmlsZW5hbWUpO1xuICAgIHJldHVybiBiaW5hcnkgPyByZXQgOiByZXQudG9TdHJpbmcoKTtcbiAgfTtcblxuICBNb2R1bGVbJ3JlYWRCaW5hcnknXSA9IGZ1bmN0aW9uIHJlYWRCaW5hcnkoZmlsZW5hbWUpIHtcbiAgICB2YXIgcmV0ID0gTW9kdWxlWydyZWFkJ10oZmlsZW5hbWUsIHRydWUpO1xuICAgIGlmICghcmV0LmJ1ZmZlcikge1xuICAgICAgcmV0ID0gbmV3IFVpbnQ4QXJyYXkocmV0KTtcbiAgICB9XG4gICAgYXNzZXJ0KHJldC5idWZmZXIpO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgaWYgKHByb2Nlc3NbJ2FyZ3YnXS5sZW5ndGggPiAxKSB7XG4gICAgTW9kdWxlWyd0aGlzUHJvZ3JhbSddID0gcHJvY2Vzc1snYXJndiddWzFdLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgfVxuXG4gIE1vZHVsZVsnYXJndW1lbnRzJ10gPSBwcm9jZXNzWydhcmd2J10uc2xpY2UoMik7XG5cbiAgLy8gTU9EVUxBUklaRSB3aWxsIGV4cG9ydCB0aGUgbW9kdWxlIGluIHRoZSBwcm9wZXIgcGxhY2Ugb3V0c2lkZSwgd2UgZG9uJ3QgbmVlZCB0byBleHBvcnQgaGVyZVxuXG4gIHByb2Nlc3NbJ29uJ10oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24oZXgpIHtcbiAgICAvLyBzdXBwcmVzcyBFeGl0U3RhdHVzIGV4Y2VwdGlvbnMgZnJvbSBzaG93aW5nIGFuIGVycm9yXG4gICAgaWYgKCEoZXggaW5zdGFuY2VvZiBFeGl0U3RhdHVzKSkge1xuICAgICAgdGhyb3cgZXg7XG4gICAgfVxuICB9KTtcbiAgLy8gQ3VycmVudGx5IG5vZGUgd2lsbCBzd2FsbG93IHVuaGFuZGxlZCByZWplY3Rpb25zLCBidXQgdGhpcyBiZWhhdmlvciBpc1xuICAvLyBkZXByZWNhdGVkLCBhbmQgaW4gdGhlIGZ1dHVyZSBpdCB3aWxsIGV4aXQgd2l0aCBlcnJvciBzdGF0dXMuXG4gIHByb2Nlc3NbJ29uJ10oJ3VuaGFuZGxlZFJlamVjdGlvbicsIGFib3J0KTtcblxuICBNb2R1bGVbJ3F1aXQnXSA9IGZ1bmN0aW9uKHN0YXR1cykge1xuICAgIHByb2Nlc3NbJ2V4aXQnXShzdGF0dXMpO1xuICB9O1xuXG4gIE1vZHVsZVsnaW5zcGVjdCddID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdJzsgfTtcbn0gZWxzZVxuaWYgKEVOVklST05NRU5UX0lTX1NIRUxMKSB7XG5cblxuICBpZiAodHlwZW9mIHJlYWQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBNb2R1bGVbJ3JlYWQnXSA9IGZ1bmN0aW9uIHNoZWxsX3JlYWQoZikge1xuICAgICAgcmV0dXJuIHJlYWQoZik7XG4gICAgfTtcbiAgfVxuXG4gIE1vZHVsZVsncmVhZEJpbmFyeSddID0gZnVuY3Rpb24gcmVhZEJpbmFyeShmKSB7XG4gICAgdmFyIGRhdGE7XG4gICAgaWYgKHR5cGVvZiByZWFkYnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVhZGJ1ZmZlcihmKSk7XG4gICAgfVxuICAgIGRhdGEgPSByZWFkKGYsICdiaW5hcnknKTtcbiAgICBhc3NlcnQodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICBpZiAodHlwZW9mIHNjcmlwdEFyZ3MgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBNb2R1bGVbJ2FyZ3VtZW50cyddID0gc2NyaXB0QXJncztcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzICE9ICd1bmRlZmluZWQnKSB7XG4gICAgTW9kdWxlWydhcmd1bWVudHMnXSA9IGFyZ3VtZW50cztcbiAgfVxuXG4gIGlmICh0eXBlb2YgcXVpdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIE1vZHVsZVsncXVpdCddID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICBxdWl0KHN0YXR1cyk7XG4gICAgfVxuICB9XG59IGVsc2VcbmlmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHsgLy8gQ2hlY2sgd29ya2VyLCBub3Qgd2ViLCBzaW5jZSB3aW5kb3cgY291bGQgYmUgcG9seWZpbGxlZFxuICAgIHNjcmlwdERpcmVjdG9yeSA9IHNlbGYubG9jYXRpb24uaHJlZjtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7IC8vIHdlYlxuICAgIHNjcmlwdERpcmVjdG9yeSA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuICB9XG4gIC8vIFdoZW4gTU9EVUxBUklaRSAoYW5kIG5vdCBfSU5TVEFOQ0UpLCB0aGlzIEpTIG1heSBiZSBleGVjdXRlZCBsYXRlciwgYWZ0ZXIgZG9jdW1lbnQuY3VycmVudFNjcmlwdFxuICAvLyBpcyBnb25lLCBzbyB3ZSBzYXZlZCBpdCwgYW5kIHdlIHVzZSBpdCBoZXJlIGluc3RlYWQgb2YgYW55IG90aGVyIGluZm8uXG4gIGlmIChfc2NyaXB0RGlyKSB7XG4gICAgc2NyaXB0RGlyZWN0b3J5ID0gX3NjcmlwdERpcjtcbiAgfVxuICAvLyBibG9iIHVybHMgbG9vayBsaWtlIGJsb2I6aHR0cDovL3NpdGUuY29tL2V0Yy9ldGMgYW5kIHdlIGNhbm5vdCBpbmZlciBhbnl0aGluZyBmcm9tIHRoZW0uXG4gIC8vIG90aGVyd2lzZSwgc2xpY2Ugb2ZmIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSB1cmwgdG8gZmluZCB0aGUgc2NyaXB0IGRpcmVjdG9yeS5cbiAgLy8gaWYgc2NyaXB0RGlyZWN0b3J5IGRvZXMgbm90IGNvbnRhaW4gYSBzbGFzaCwgbGFzdEluZGV4T2Ygd2lsbCByZXR1cm4gLTEsXG4gIC8vIGFuZCBzY3JpcHREaXJlY3Rvcnkgd2lsbCBjb3JyZWN0bHkgYmUgcmVwbGFjZWQgd2l0aCBhbiBlbXB0eSBzdHJpbmcuXG4gIGlmIChzY3JpcHREaXJlY3RvcnkuaW5kZXhPZignYmxvYjonKSAhPT0gMCkge1xuICAgIHNjcmlwdERpcmVjdG9yeSA9IHNjcmlwdERpcmVjdG9yeS5zdWJzdHIoMCwgc2NyaXB0RGlyZWN0b3J5Lmxhc3RJbmRleE9mKCcvJykrMSk7XG4gIH0gZWxzZSB7XG4gICAgc2NyaXB0RGlyZWN0b3J5ID0gJyc7XG4gIH1cblxuXG4gIE1vZHVsZVsncmVhZCddID0gZnVuY3Rpb24gc2hlbGxfcmVhZCh1cmwpIHtcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcbiAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVRleHQ7XG4gIH07XG5cbiAgaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikge1xuICAgIE1vZHVsZVsncmVhZEJpbmFyeSddID0gZnVuY3Rpb24gcmVhZEJpbmFyeSh1cmwpIHtcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSk7XG4gICAgfTtcbiAgfVxuXG4gIE1vZHVsZVsncmVhZEFzeW5jJ10gPSBmdW5jdGlvbiByZWFkQXN5bmModXJsLCBvbmxvYWQsIG9uZXJyb3IpIHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIHhocl9vbmxvYWQoKSB7XG4gICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDAgfHwgKHhoci5zdGF0dXMgPT0gMCAmJiB4aHIucmVzcG9uc2UpKSB7IC8vIGZpbGUgVVJMcyBjYW4gcmV0dXJuIDBcbiAgICAgICAgb25sb2FkKHhoci5yZXNwb25zZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9uZXJyb3IoKTtcbiAgICB9O1xuICAgIHhoci5vbmVycm9yID0gb25lcnJvcjtcbiAgICB4aHIuc2VuZChudWxsKTtcbiAgfTtcblxuICBNb2R1bGVbJ3NldFdpbmRvd1RpdGxlJ10gPSBmdW5jdGlvbih0aXRsZSkgeyBkb2N1bWVudC50aXRsZSA9IHRpdGxlIH07XG59IGVsc2Vcbntcbn1cblxuLy8gU2V0IHVwIHRoZSBvdXQoKSBhbmQgZXJyKCkgaG9va3MsIHdoaWNoIGFyZSBob3cgd2UgY2FuIHByaW50IHRvIHN0ZG91dCBvclxuLy8gc3RkZXJyLCByZXNwZWN0aXZlbHkuXG4vLyBJZiB0aGUgdXNlciBwcm92aWRlZCBNb2R1bGUucHJpbnQgb3IgcHJpbnRFcnIsIHVzZSB0aGF0LiBPdGhlcndpc2UsXG4vLyBjb25zb2xlLmxvZyBpcyBjaGVja2VkIGZpcnN0LCBhcyAncHJpbnQnIG9uIHRoZSB3ZWIgd2lsbCBvcGVuIGEgcHJpbnQgZGlhbG9ndWVcbi8vIHByaW50RXJyIGlzIHByZWZlcmFibGUgdG8gY29uc29sZS53YXJuICh3b3JrcyBiZXR0ZXIgaW4gc2hlbGxzKVxuLy8gYmluZChjb25zb2xlKSBpcyBuZWNlc3NhcnkgdG8gZml4IElFL0VkZ2UgY2xvc2VkIGRldiB0b29scyBwYW5lbCBiZWhhdmlvci5cbnZhciBvdXQgPSBNb2R1bGVbJ3ByaW50J10gfHwgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyA/IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkgOiAodHlwZW9mIHByaW50ICE9PSAndW5kZWZpbmVkJyA/IHByaW50IDogbnVsbCkpO1xudmFyIGVyciA9IE1vZHVsZVsncHJpbnRFcnInXSB8fCAodHlwZW9mIHByaW50RXJyICE9PSAndW5kZWZpbmVkJyA/IHByaW50RXJyIDogKCh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuLmJpbmQoY29uc29sZSkpIHx8IG91dCkpO1xuXG4vLyBNZXJnZSBiYWNrIGluIHRoZSBvdmVycmlkZXNcbmZvciAoa2V5IGluIG1vZHVsZU92ZXJyaWRlcykge1xuICBpZiAobW9kdWxlT3ZlcnJpZGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICBNb2R1bGVba2V5XSA9IG1vZHVsZU92ZXJyaWRlc1trZXldO1xuICB9XG59XG4vLyBGcmVlIHRoZSBvYmplY3QgaGllcmFyY2h5IGNvbnRhaW5lZCBpbiB0aGUgb3ZlcnJpZGVzLCB0aGlzIGxldHMgdGhlIEdDXG4vLyByZWNsYWltIGRhdGEgdXNlZCBlLmcuIGluIG1lbW9yeUluaXRpYWxpemVyUmVxdWVzdCwgd2hpY2ggaXMgYSBsYXJnZSB0eXBlZCBhcnJheS5cbm1vZHVsZU92ZXJyaWRlcyA9IHVuZGVmaW5lZDtcblxuXG5cbi8vIENvcHlyaWdodCAyMDE3IFRoZSBFbXNjcmlwdGVuIEF1dGhvcnMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gRW1zY3JpcHRlbiBpcyBhdmFpbGFibGUgdW5kZXIgdHdvIHNlcGFyYXRlIGxpY2Vuc2VzLCB0aGUgTUlUIGxpY2Vuc2UgYW5kIHRoZVxuLy8gVW5pdmVyc2l0eSBvZiBJbGxpbm9pcy9OQ1NBIE9wZW4gU291cmNlIExpY2Vuc2UuICBCb3RoIHRoZXNlIGxpY2Vuc2VzIGNhbiBiZVxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cblxuLy8ge3tQUkVBTUJMRV9BRERJVElPTlN9fVxuXG52YXIgU1RBQ0tfQUxJR04gPSAxNjtcblxuXG5mdW5jdGlvbiBzdGF0aWNBbGxvYyhzaXplKSB7XG4gIHZhciByZXQgPSBTVEFUSUNUT1A7XG4gIFNUQVRJQ1RPUCA9IChTVEFUSUNUT1AgKyBzaXplICsgMTUpICYgLTE2O1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkeW5hbWljQWxsb2Moc2l6ZSkge1xuICB2YXIgcmV0ID0gSEVBUDMyW0RZTkFNSUNUT1BfUFRSPj4yXTtcbiAgdmFyIGVuZCA9IChyZXQgKyBzaXplICsgMTUpICYgLTE2O1xuICBIRUFQMzJbRFlOQU1JQ1RPUF9QVFI+PjJdID0gZW5kO1xuICBpZiAoZW5kID49IFRPVEFMX01FTU9SWSkge1xuICAgIHZhciBzdWNjZXNzID0gZW5sYXJnZU1lbW9yeSgpO1xuICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgSEVBUDMyW0RZTkFNSUNUT1BfUFRSPj4yXSA9IHJldDtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBhbGlnbk1lbW9yeShzaXplLCBmYWN0b3IpIHtcbiAgaWYgKCFmYWN0b3IpIGZhY3RvciA9IFNUQUNLX0FMSUdOOyAvLyBzdGFjayBhbGlnbm1lbnQgKDE2LWJ5dGUpIGJ5IGRlZmF1bHRcbiAgdmFyIHJldCA9IHNpemUgPSBNYXRoLmNlaWwoc2l6ZSAvIGZhY3RvcikgKiBmYWN0b3I7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGdldE5hdGl2ZVR5cGVTaXplKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnaTEnOiBjYXNlICdpOCc6IHJldHVybiAxO1xuICAgIGNhc2UgJ2kxNic6IHJldHVybiAyO1xuICAgIGNhc2UgJ2kzMic6IHJldHVybiA0O1xuICAgIGNhc2UgJ2k2NCc6IHJldHVybiA4O1xuICAgIGNhc2UgJ2Zsb2F0JzogcmV0dXJuIDQ7XG4gICAgY2FzZSAnZG91YmxlJzogcmV0dXJuIDg7XG4gICAgZGVmYXVsdDoge1xuICAgICAgaWYgKHR5cGVbdHlwZS5sZW5ndGgtMV0gPT09ICcqJykge1xuICAgICAgICByZXR1cm4gNDsgLy8gQSBwb2ludGVyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVbMF0gPT09ICdpJykge1xuICAgICAgICB2YXIgYml0cyA9IHBhcnNlSW50KHR5cGUuc3Vic3RyKDEpKTtcbiAgICAgICAgYXNzZXJ0KGJpdHMgJSA4ID09PSAwKTtcbiAgICAgICAgcmV0dXJuIGJpdHMgLyA4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PbmNlKHRleHQpIHtcbiAgaWYgKCF3YXJuT25jZS5zaG93bikgd2Fybk9uY2Uuc2hvd24gPSB7fTtcbiAgaWYgKCF3YXJuT25jZS5zaG93blt0ZXh0XSkge1xuICAgIHdhcm5PbmNlLnNob3duW3RleHRdID0gMTtcbiAgICBlcnIodGV4dCk7XG4gIH1cbn1cblxudmFyIGFzbTJ3YXNtSW1wb3J0cyA9IHsgLy8gc3BlY2lhbCBhc20yd2FzbSBpbXBvcnRzXG4gICAgXCJmNjQtcmVtXCI6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHggJSB5O1xuICAgIH0sXG4gICAgXCJkZWJ1Z2dlclwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVidWdnZXI7XG4gICAgfVxufTtcblxuXG5cbnZhciBqc0NhbGxTdGFydEluZGV4ID0gMTtcbnZhciBmdW5jdGlvblBvaW50ZXJzID0gbmV3IEFycmF5KDApO1xuXG4vLyAnc2lnJyBwYXJhbWV0ZXIgaXMgb25seSB1c2VkIG9uIExMVk0gd2FzbSBiYWNrZW5kXG5mdW5jdGlvbiBhZGRGdW5jdGlvbihmdW5jLCBzaWcpIHtcbiAgdmFyIGJhc2UgPSAwO1xuICBmb3IgKHZhciBpID0gYmFzZTsgaSA8IGJhc2UgKyAwOyBpKyspIHtcbiAgICBpZiAoIWZ1bmN0aW9uUG9pbnRlcnNbaV0pIHtcbiAgICAgIGZ1bmN0aW9uUG9pbnRlcnNbaV0gPSBmdW5jO1xuICAgICAgcmV0dXJuIGpzQ2FsbFN0YXJ0SW5kZXggKyBpO1xuICAgIH1cbiAgfVxuICB0aHJvdyAnRmluaXNoZWQgdXAgYWxsIHJlc2VydmVkIGZ1bmN0aW9uIHBvaW50ZXJzLiBVc2UgYSBoaWdoZXIgdmFsdWUgZm9yIFJFU0VSVkVEX0ZVTkNUSU9OX1BPSU5URVJTLic7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZ1bmN0aW9uKGluZGV4KSB7XG4gIGZ1bmN0aW9uUG9pbnRlcnNbaW5kZXgtanNDYWxsU3RhcnRJbmRleF0gPSBudWxsO1xufVxuXG52YXIgZnVuY1dyYXBwZXJzID0ge307XG5cbmZ1bmN0aW9uIGdldEZ1bmNXcmFwcGVyKGZ1bmMsIHNpZykge1xuICBpZiAoIWZ1bmMpIHJldHVybjsgLy8gb24gbnVsbCBwb2ludGVyLCByZXR1cm4gdW5kZWZpbmVkXG4gIGFzc2VydChzaWcpO1xuICBpZiAoIWZ1bmNXcmFwcGVyc1tzaWddKSB7XG4gICAgZnVuY1dyYXBwZXJzW3NpZ10gPSB7fTtcbiAgfVxuICB2YXIgc2lnQ2FjaGUgPSBmdW5jV3JhcHBlcnNbc2lnXTtcbiAgaWYgKCFzaWdDYWNoZVtmdW5jXSkge1xuICAgIC8vIG9wdGltaXplIGF3YXkgYXJndW1lbnRzIHVzYWdlIGluIGNvbW1vbiBjYXNlc1xuICAgIGlmIChzaWcubGVuZ3RoID09PSAxKSB7XG4gICAgICBzaWdDYWNoZVtmdW5jXSA9IGZ1bmN0aW9uIGR5bkNhbGxfd3JhcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIGR5bkNhbGwoc2lnLCBmdW5jKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzaWcubGVuZ3RoID09PSAyKSB7XG4gICAgICBzaWdDYWNoZVtmdW5jXSA9IGZ1bmN0aW9uIGR5bkNhbGxfd3JhcHBlcihhcmcpIHtcbiAgICAgICAgcmV0dXJuIGR5bkNhbGwoc2lnLCBmdW5jLCBbYXJnXSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZW5lcmFsIGNhc2VcbiAgICAgIHNpZ0NhY2hlW2Z1bmNdID0gZnVuY3Rpb24gZHluQ2FsbF93cmFwcGVyKCkge1xuICAgICAgICByZXR1cm4gZHluQ2FsbChzaWcsIGZ1bmMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNpZ0NhY2hlW2Z1bmNdO1xufVxuXG5cbmZ1bmN0aW9uIG1ha2VCaWdJbnQobG93LCBoaWdoLCB1bnNpZ25lZCkge1xuICByZXR1cm4gdW5zaWduZWQgPyAoKCsoKGxvdz4+PjApKSkrKCgrKChoaWdoPj4+MCkpKSo0Mjk0OTY3Mjk2LjApKSA6ICgoKygobG93Pj4+MCkpKSsoKCsoKGhpZ2h8MCkpKSo0Mjk0OTY3Mjk2LjApKTtcbn1cblxuZnVuY3Rpb24gZHluQ2FsbChzaWcsIHB0ciwgYXJncykge1xuICBpZiAoYXJncyAmJiBhcmdzLmxlbmd0aCkge1xuICAgIHJldHVybiBNb2R1bGVbJ2R5bkNhbGxfJyArIHNpZ10uYXBwbHkobnVsbCwgW3B0cl0uY29uY2F0KGFyZ3MpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gTW9kdWxlWydkeW5DYWxsXycgKyBzaWddLmNhbGwobnVsbCwgcHRyKTtcbiAgfVxufVxuXG5cblxudmFyIFJ1bnRpbWUgPSB7XG4gIC8vIEZJWE1FIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGxheWVyIGZvciBwb3J0cy4gU3VwcG9ydCBzb21lIFJ1bnRpbWUuKlxuICAvLyAgICAgICBmb3Igbm93LCBmaXggaXQgdGhlcmUsIHRoZW4gcmVtb3ZlIGl0IGZyb20gaGVyZS4gVGhhdCB3YXkgd2VcbiAgLy8gICAgICAgY2FuIG1pbmltaXplIGFueSBwZXJpb2Qgb2YgYnJlYWthZ2UuXG4gIGR5bkNhbGw6IGR5bkNhbGwsIC8vIGZvciBTREwyIHBvcnRcbn07XG5cbi8vIFRoZSBhZGRyZXNzIGdsb2JhbHMgYmVnaW4gYXQuIFZlcnkgbG93IGluIG1lbW9yeSwgZm9yIGNvZGUgc2l6ZSBhbmQgb3B0aW1pemF0aW9uIG9wcG9ydHVuaXRpZXMuXG4vLyBBYm92ZSAwIGlzIHN0YXRpYyBtZW1vcnksIHN0YXJ0aW5nIHdpdGggZ2xvYmFscy5cbi8vIFRoZW4gdGhlIHN0YWNrLlxuLy8gVGhlbiAnZHluYW1pYycgbWVtb3J5IGZvciBzYnJrLlxudmFyIEdMT0JBTF9CQVNFID0gMTAyNDtcblxuXG4vLyA9PT0gUHJlYW1ibGUgbGlicmFyeSBzdHVmZiA9PT1cblxuLy8gRG9jdW1lbnRhdGlvbiBmb3IgdGhlIHB1YmxpYyBBUElzIGRlZmluZWQgaW4gdGhpcyBmaWxlIG11c3QgYmUgdXBkYXRlZCBpbjpcbi8vICAgIHNpdGUvc291cmNlL2RvY3MvYXBpX3JlZmVyZW5jZS9wcmVhbWJsZS5qcy5yc3Rcbi8vIEEgcHJlYnVpbHQgbG9jYWwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnRhdGlvbiBpcyBhdmFpbGFibGUgYXQ6XG4vLyAgICBzaXRlL2J1aWxkL3RleHQvZG9jcy9hcGlfcmVmZXJlbmNlL3ByZWFtYmxlLmpzLnR4dFxuLy8gWW91IGNhbiBhbHNvIGJ1aWxkIGRvY3MgbG9jYWxseSBhcyBIVE1MIG9yIG90aGVyIGZvcm1hdHMgaW4gc2l0ZS9cbi8vIEFuIG9ubGluZSBIVE1MIHZlcnNpb24gKHdoaWNoIG1heSBiZSBvZiBhIGRpZmZlcmVudCB2ZXJzaW9uIG9mIEVtc2NyaXB0ZW4pXG4vLyAgICBpcyB1cCBhdCBodHRwOi8va3JpcGtlbi5naXRodWIuaW8vZW1zY3JpcHRlbi1zaXRlL2RvY3MvYXBpX3JlZmVyZW5jZS9wcmVhbWJsZS5qcy5odG1sXG5cblxuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFJ1bnRpbWUgZXNzZW50aWFsc1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8vIHdoZXRoZXIgd2UgYXJlIHF1aXR0aW5nIHRoZSBhcHBsaWNhdGlvbi4gbm8gY29kZSBzaG91bGQgcnVuIGFmdGVyIHRoaXMuXG4vLyBzZXQgaW4gZXhpdCgpIGFuZCBhYm9ydCgpXG52YXIgQUJPUlQgPSBmYWxzZTtcblxuLy8gc2V0IGJ5IGV4aXQoKSBhbmQgYWJvcnQoKS4gIFBhc3NlZCB0byAnb25FeGl0JyBoYW5kbGVyLlxuLy8gTk9URTogVGhpcyBpcyBhbHNvIHVzZWQgYXMgdGhlIHByb2Nlc3MgcmV0dXJuIGNvZGUgY29kZSBpbiBzaGVsbCBlbnZpcm9ubWVudHNcbi8vIGJ1dCBvbmx5IHdoZW4gbm9FeGl0UnVudGltZSBpcyBmYWxzZS5cbnZhciBFWElUU1RBVFVTID0gMDtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbigqLCBzdHJpbmc9KX0gKi9cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIHRleHQpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICBhYm9ydCgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIHRleHQpO1xuICB9XG59XG5cbnZhciBnbG9iYWxTY29wZSA9IHRoaXM7XG5cbi8vIFJldHVybnMgdGhlIEMgZnVuY3Rpb24gd2l0aCBhIHNwZWNpZmllZCBpZGVudGlmaWVyIChmb3IgQysrLCB5b3UgbmVlZCB0byBkbyBtYW51YWwgbmFtZSBtYW5nbGluZylcbmZ1bmN0aW9uIGdldENGdW5jKGlkZW50KSB7XG4gIHZhciBmdW5jID0gTW9kdWxlWydfJyArIGlkZW50XTsgLy8gY2xvc3VyZSBleHBvcnRlZCBmdW5jdGlvblxuICBhc3NlcnQoZnVuYywgJ0Nhbm5vdCBjYWxsIHVua25vd24gZnVuY3Rpb24gJyArIGlkZW50ICsgJywgbWFrZSBzdXJlIGl0IGlzIGV4cG9ydGVkJyk7XG4gIHJldHVybiBmdW5jO1xufVxuXG52YXIgSlNmdW5jcyA9IHtcbiAgLy8gSGVscGVycyBmb3IgY3dyYXAgLS0gaXQgY2FuJ3QgcmVmZXIgdG8gUnVudGltZSBkaXJlY3RseSBiZWNhdXNlIGl0IG1pZ2h0XG4gIC8vIGJlIHJlbmFtZWQgYnkgY2xvc3VyZSwgaW5zdGVhZCBpdCBjYWxscyBKU2Z1bmNzWydzdGFja1NhdmUnXS5ib2R5IHRvIGZpbmRcbiAgLy8gb3V0IHdoYXQgdGhlIG1pbmlmaWVkIGZ1bmN0aW9uIG5hbWUgaXMuXG4gICdzdGFja1NhdmUnOiBmdW5jdGlvbigpIHtcbiAgICBzdGFja1NhdmUoKVxuICB9LFxuICAnc3RhY2tSZXN0b3JlJzogZnVuY3Rpb24oKSB7XG4gICAgc3RhY2tSZXN0b3JlKClcbiAgfSxcbiAgLy8gdHlwZSBjb252ZXJzaW9uIGZyb20ganMgdG8gY1xuICAnYXJyYXlUb0MnIDogZnVuY3Rpb24oYXJyKSB7XG4gICAgdmFyIHJldCA9IHN0YWNrQWxsb2MoYXJyLmxlbmd0aCk7XG4gICAgd3JpdGVBcnJheVRvTWVtb3J5KGFyciwgcmV0KTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICAnc3RyaW5nVG9DJyA6IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciByZXQgPSAwO1xuICAgIGlmIChzdHIgIT09IG51bGwgJiYgc3RyICE9PSB1bmRlZmluZWQgJiYgc3RyICE9PSAwKSB7IC8vIG51bGwgc3RyaW5nXG4gICAgICAvLyBhdCBtb3N0IDQgYnl0ZXMgcGVyIFVURi04IGNvZGUgcG9pbnQsICsxIGZvciB0aGUgdHJhaWxpbmcgJ1xcMCdcbiAgICAgIHZhciBsZW4gPSAoc3RyLmxlbmd0aCA8PCAyKSArIDE7XG4gICAgICByZXQgPSBzdGFja0FsbG9jKGxlbik7XG4gICAgICBzdHJpbmdUb1VURjgoc3RyLCByZXQsIGxlbik7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbn07XG5cbi8vIEZvciBmYXN0IGxvb2t1cCBvZiBjb252ZXJzaW9uIGZ1bmN0aW9uc1xudmFyIHRvQyA9IHtcbiAgJ3N0cmluZyc6IEpTZnVuY3NbJ3N0cmluZ1RvQyddLCAnYXJyYXknOiBKU2Z1bmNzWydhcnJheVRvQyddXG59O1xuXG5cbi8vIEMgY2FsbGluZyBpbnRlcmZhY2UuXG5mdW5jdGlvbiBjY2FsbChpZGVudCwgcmV0dXJuVHlwZSwgYXJnVHlwZXMsIGFyZ3MsIG9wdHMpIHtcbiAgZnVuY3Rpb24gY29udmVydFJldHVyblZhbHVlKHJldCkge1xuICAgIGlmIChyZXR1cm5UeXBlID09PSAnc3RyaW5nJykgcmV0dXJuIFBvaW50ZXJfc3RyaW5naWZ5KHJldCk7XG4gICAgaWYgKHJldHVyblR5cGUgPT09ICdib29sZWFuJykgcmV0dXJuIEJvb2xlYW4ocmV0KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgdmFyIGZ1bmMgPSBnZXRDRnVuYyhpZGVudCk7XG4gIHZhciBjQXJncyA9IFtdO1xuICB2YXIgc3RhY2sgPSAwO1xuICBpZiAoYXJncykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvbnZlcnRlciA9IHRvQ1thcmdUeXBlc1tpXV07XG4gICAgICBpZiAoY29udmVydGVyKSB7XG4gICAgICAgIGlmIChzdGFjayA9PT0gMCkgc3RhY2sgPSBzdGFja1NhdmUoKTtcbiAgICAgICAgY0FyZ3NbaV0gPSBjb252ZXJ0ZXIoYXJnc1tpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjQXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciByZXQgPSBmdW5jLmFwcGx5KG51bGwsIGNBcmdzKTtcbiAgcmV0ID0gY29udmVydFJldHVyblZhbHVlKHJldCk7XG4gIGlmIChzdGFjayAhPT0gMCkgc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gY3dyYXAoaWRlbnQsIHJldHVyblR5cGUsIGFyZ1R5cGVzLCBvcHRzKSB7XG4gIGFyZ1R5cGVzID0gYXJnVHlwZXMgfHwgW107XG4gIC8vIFdoZW4gdGhlIGZ1bmN0aW9uIHRha2VzIG51bWJlcnMgYW5kIHJldHVybnMgYSBudW1iZXIsIHdlIGNhbiBqdXN0IHJldHVyblxuICAvLyB0aGUgb3JpZ2luYWwgZnVuY3Rpb25cbiAgdmFyIG51bWVyaWNBcmdzID0gYXJnVHlwZXMuZXZlcnkoZnVuY3Rpb24odHlwZSl7IHJldHVybiB0eXBlID09PSAnbnVtYmVyJ30pO1xuICB2YXIgbnVtZXJpY1JldCA9IHJldHVyblR5cGUgIT09ICdzdHJpbmcnO1xuICBpZiAobnVtZXJpY1JldCAmJiBudW1lcmljQXJncyAmJiAhb3B0cykge1xuICAgIHJldHVybiBnZXRDRnVuYyhpZGVudCk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjY2FsbChpZGVudCwgcmV0dXJuVHlwZSwgYXJnVHlwZXMsIGFyZ3VtZW50cywgb3B0cyk7XG4gIH1cbn1cblxuLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsIG51bWJlciwgc3RyaW5nLCBib29sZWFuPSl9ICovXG5mdW5jdGlvbiBzZXRWYWx1ZShwdHIsIHZhbHVlLCB0eXBlLCBub1NhZmUpIHtcbiAgdHlwZSA9IHR5cGUgfHwgJ2k4JztcbiAgaWYgKHR5cGUuY2hhckF0KHR5cGUubGVuZ3RoLTEpID09PSAnKicpIHR5cGUgPSAnaTMyJzsgLy8gcG9pbnRlcnMgYXJlIDMyLWJpdFxuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICBjYXNlICdpMSc6IEhFQVA4WygocHRyKT4+MCldPXZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgJ2k4JzogSEVBUDhbKChwdHIpPj4wKV09dmFsdWU7IGJyZWFrO1xuICAgICAgY2FzZSAnaTE2JzogSEVBUDE2WygocHRyKT4+MSldPXZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgJ2kzMic6IEhFQVAzMlsoKHB0cik+PjIpXT12YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlICdpNjQnOiAodGVtcEk2NCA9IFt2YWx1ZT4+PjAsKHRlbXBEb3VibGU9dmFsdWUsKCsoTWF0aF9hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aF9taW4oKCsoTWF0aF9mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aF9jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKChwdHIpPj4yKV09dGVtcEk2NFswXSxIRUFQMzJbKCgocHRyKSsoNCkpPj4yKV09dGVtcEk2NFsxXSk7IGJyZWFrO1xuICAgICAgY2FzZSAnZmxvYXQnOiBIRUFQRjMyWygocHRyKT4+MildPXZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgJ2RvdWJsZSc6IEhFQVBGNjRbKChwdHIpPj4zKV09dmFsdWU7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogYWJvcnQoJ2ludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICcgKyB0eXBlKTtcbiAgICB9XG59XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLCBzdHJpbmcsIGJvb2xlYW49KX0gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKHB0ciwgdHlwZSwgbm9TYWZlKSB7XG4gIHR5cGUgPSB0eXBlIHx8ICdpOCc7XG4gIGlmICh0eXBlLmNoYXJBdCh0eXBlLmxlbmd0aC0xKSA9PT0gJyonKSB0eXBlID0gJ2kzMic7IC8vIHBvaW50ZXJzIGFyZSAzMi1iaXRcbiAgICBzd2l0Y2godHlwZSkge1xuICAgICAgY2FzZSAnaTEnOiByZXR1cm4gSEVBUDhbKChwdHIpPj4wKV07XG4gICAgICBjYXNlICdpOCc6IHJldHVybiBIRUFQOFsoKHB0cik+PjApXTtcbiAgICAgIGNhc2UgJ2kxNic6IHJldHVybiBIRUFQMTZbKChwdHIpPj4xKV07XG4gICAgICBjYXNlICdpMzInOiByZXR1cm4gSEVBUDMyWygocHRyKT4+MildO1xuICAgICAgY2FzZSAnaTY0JzogcmV0dXJuIEhFQVAzMlsoKHB0cik+PjIpXTtcbiAgICAgIGNhc2UgJ2Zsb2F0JzogcmV0dXJuIEhFQVBGMzJbKChwdHIpPj4yKV07XG4gICAgICBjYXNlICdkb3VibGUnOiByZXR1cm4gSEVBUEY2NFsoKHB0cik+PjMpXTtcbiAgICAgIGRlZmF1bHQ6IGFib3J0KCdpbnZhbGlkIHR5cGUgZm9yIGdldFZhbHVlOiAnICsgdHlwZSk7XG4gICAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIEFMTE9DX05PUk1BTCA9IDA7IC8vIFRyaWVzIHRvIHVzZSBfbWFsbG9jKClcbnZhciBBTExPQ19TVEFDSyA9IDE7IC8vIExpdmVzIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGN1cnJlbnQgZnVuY3Rpb24gY2FsbFxudmFyIEFMTE9DX1NUQVRJQyA9IDI7IC8vIENhbm5vdCBiZSBmcmVlZFxudmFyIEFMTE9DX0RZTkFNSUMgPSAzOyAvLyBDYW5ub3QgYmUgZnJlZWQgZXhjZXB0IHRocm91Z2ggc2Jya1xudmFyIEFMTE9DX05PTkUgPSA0OyAvLyBEbyBub3QgYWxsb2NhdGVcblxuLy8gYWxsb2NhdGUoKTogVGhpcyBpcyBmb3IgaW50ZXJuYWwgdXNlLiBZb3UgY2FuIHVzZSBpdCB5b3Vyc2VsZiBhcyB3ZWxsLCBidXQgdGhlIGludGVyZmFjZVxuLy8gICAgICAgICAgICAgaXMgYSBsaXR0bGUgdHJpY2t5IChzZWUgZG9jcyByaWdodCBiZWxvdykuIFRoZSByZWFzb24gaXMgdGhhdCBpdCBpcyBvcHRpbWl6ZWRcbi8vICAgICAgICAgICAgIGZvciBtdWx0aXBsZSBzeW50YXhlcyB0byBzYXZlIHNwYWNlIGluIGdlbmVyYXRlZCBjb2RlLiBTbyB5b3Ugc2hvdWxkXG4vLyAgICAgICAgICAgICBub3JtYWxseSBub3QgdXNlIGFsbG9jYXRlKCksIGFuZCBpbnN0ZWFkIGFsbG9jYXRlIG1lbW9yeSB1c2luZyBfbWFsbG9jKCksXG4vLyAgICAgICAgICAgICBpbml0aWFsaXplIGl0IHdpdGggc2V0VmFsdWUoKSwgYW5kIHNvIGZvcnRoLlxuLy8gQHNsYWI6IEFuIGFycmF5IG9mIGRhdGEsIG9yIGEgbnVtYmVyLiBJZiBhIG51bWJlciwgdGhlbiB0aGUgc2l6ZSBvZiB0aGUgYmxvY2sgdG8gYWxsb2NhdGUsXG4vLyAgICAgICAgaW4gKmJ5dGVzKiAobm90ZSB0aGF0IHRoaXMgaXMgc29tZXRpbWVzIGNvbmZ1c2luZzogdGhlIG5leHQgcGFyYW1ldGVyIGRvZXMgbm90XG4vLyAgICAgICAgYWZmZWN0IHRoaXMhKVxuLy8gQHR5cGVzOiBFaXRoZXIgYW4gYXJyYXkgb2YgdHlwZXMsIG9uZSBmb3IgZWFjaCBieXRlIChvciAwIGlmIG5vIHR5cGUgYXQgdGhhdCBwb3NpdGlvbiksXG4vLyAgICAgICAgIG9yIGEgc2luZ2xlIHR5cGUgd2hpY2ggaXMgdXNlZCBmb3IgdGhlIGVudGlyZSBibG9jay4gVGhpcyBvbmx5IG1hdHRlcnMgaWYgdGhlcmVcbi8vICAgICAgICAgaXMgaW5pdGlhbCBkYXRhIC0gaWYgQHNsYWIgaXMgYSBudW1iZXIsIHRoZW4gdGhpcyBkb2VzIG5vdCBtYXR0ZXIgYXQgYWxsIGFuZCBpc1xuLy8gICAgICAgICBpZ25vcmVkLlxuLy8gQGFsbG9jYXRvcjogSG93IHRvIGFsbG9jYXRlIG1lbW9yeSwgc2VlIEFMTE9DXypcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oKFR5cGVkQXJyYXl8QXJyYXk8bnVtYmVyPnxudW1iZXIpLCBzdHJpbmcsIG51bWJlciwgbnVtYmVyPSl9ICovXG5mdW5jdGlvbiBhbGxvY2F0ZShzbGFiLCB0eXBlcywgYWxsb2NhdG9yLCBwdHIpIHtcbiAgdmFyIHplcm9pbml0LCBzaXplO1xuICBpZiAodHlwZW9mIHNsYWIgPT09ICdudW1iZXInKSB7XG4gICAgemVyb2luaXQgPSB0cnVlO1xuICAgIHNpemUgPSBzbGFiO1xuICB9IGVsc2Uge1xuICAgIHplcm9pbml0ID0gZmFsc2U7XG4gICAgc2l6ZSA9IHNsYWIubGVuZ3RoO1xuICB9XG5cbiAgdmFyIHNpbmdsZVR5cGUgPSB0eXBlb2YgdHlwZXMgPT09ICdzdHJpbmcnID8gdHlwZXMgOiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChhbGxvY2F0b3IgPT0gQUxMT0NfTk9ORSkge1xuICAgIHJldCA9IHB0cjtcbiAgfSBlbHNlIHtcbiAgICByZXQgPSBbdHlwZW9mIF9tYWxsb2MgPT09ICdmdW5jdGlvbicgPyBfbWFsbG9jIDogc3RhdGljQWxsb2MsIHN0YWNrQWxsb2MsIHN0YXRpY0FsbG9jLCBkeW5hbWljQWxsb2NdW2FsbG9jYXRvciA9PT0gdW5kZWZpbmVkID8gQUxMT0NfU1RBVElDIDogYWxsb2NhdG9yXShNYXRoLm1heChzaXplLCBzaW5nbGVUeXBlID8gMSA6IHR5cGVzLmxlbmd0aCkpO1xuICB9XG5cbiAgaWYgKHplcm9pbml0KSB7XG4gICAgdmFyIHN0b3A7XG4gICAgcHRyID0gcmV0O1xuICAgIGFzc2VydCgocmV0ICYgMykgPT0gMCk7XG4gICAgc3RvcCA9IHJldCArIChzaXplICYgfjMpO1xuICAgIGZvciAoOyBwdHIgPCBzdG9wOyBwdHIgKz0gNCkge1xuICAgICAgSEVBUDMyWygocHRyKT4+MildPTA7XG4gICAgfVxuICAgIHN0b3AgPSByZXQgKyBzaXplO1xuICAgIHdoaWxlIChwdHIgPCBzdG9wKSB7XG4gICAgICBIRUFQOFsoKHB0cisrKT4+MCldPTA7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpZiAoc2luZ2xlVHlwZSA9PT0gJ2k4Jykge1xuICAgIGlmIChzbGFiLnN1YmFycmF5IHx8IHNsYWIuc2xpY2UpIHtcbiAgICAgIEhFQVBVOC5zZXQoLyoqIEB0eXBlIHshVWludDhBcnJheX0gKi8gKHNsYWIpLCByZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBIRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KHNsYWIpLCByZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgdmFyIGkgPSAwLCB0eXBlLCB0eXBlU2l6ZSwgcHJldmlvdXNUeXBlO1xuICB3aGlsZSAoaSA8IHNpemUpIHtcbiAgICB2YXIgY3VyciA9IHNsYWJbaV07XG5cbiAgICB0eXBlID0gc2luZ2xlVHlwZSB8fCB0eXBlc1tpXTtcbiAgICBpZiAodHlwZSA9PT0gMCkge1xuICAgICAgaSsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT0gJ2k2NCcpIHR5cGUgPSAnaTMyJzsgLy8gc3BlY2lhbCBjYXNlOiB3ZSBoYXZlIG9uZSBpMzIgaGVyZSwgYW5kIG9uZSBpMzIgbGF0ZXJcblxuICAgIHNldFZhbHVlKHJldCtpLCBjdXJyLCB0eXBlKTtcblxuICAgIC8vIG5vIG5lZWQgdG8gbG9vayB1cCBzaXplIHVubGVzcyB0eXBlIGNoYW5nZXMsIHNvIGNhY2hlIGl0XG4gICAgaWYgKHByZXZpb3VzVHlwZSAhPT0gdHlwZSkge1xuICAgICAgdHlwZVNpemUgPSBnZXROYXRpdmVUeXBlU2l6ZSh0eXBlKTtcbiAgICAgIHByZXZpb3VzVHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIGkgKz0gdHlwZVNpemU7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBBbGxvY2F0ZSBtZW1vcnkgZHVyaW5nIGFueSBzdGFnZSBvZiBzdGFydHVwIC0gc3RhdGljIG1lbW9yeSBlYXJseSBvbiwgZHluYW1pYyBtZW1vcnkgbGF0ZXIsIG1hbGxvYyB3aGVuIHJlYWR5XG5mdW5jdGlvbiBnZXRNZW1vcnkoc2l6ZSkge1xuICBpZiAoIXN0YXRpY1NlYWxlZCkgcmV0dXJuIHN0YXRpY0FsbG9jKHNpemUpO1xuICBpZiAoIXJ1bnRpbWVJbml0aWFsaXplZCkgcmV0dXJuIGR5bmFtaWNBbGxvYyhzaXplKTtcbiAgcmV0dXJuIF9tYWxsb2Moc2l6ZSk7XG59XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXI9KX0gKi9cbmZ1bmN0aW9uIFBvaW50ZXJfc3RyaW5naWZ5KHB0ciwgbGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPT09IDAgfHwgIXB0cikgcmV0dXJuICcnO1xuICAvLyBGaW5kIHRoZSBsZW5ndGgsIGFuZCBjaGVjayBmb3IgVVRGIHdoaWxlIGRvaW5nIHNvXG4gIHZhciBoYXNVdGYgPSAwO1xuICB2YXIgdDtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoMSkge1xuICAgIHQgPSBIRUFQVThbKCgocHRyKSsoaSkpPj4wKV07XG4gICAgaGFzVXRmIHw9IHQ7XG4gICAgaWYgKHQgPT0gMCAmJiAhbGVuZ3RoKSBicmVhaztcbiAgICBpKys7XG4gICAgaWYgKGxlbmd0aCAmJiBpID09IGxlbmd0aCkgYnJlYWs7XG4gIH1cbiAgaWYgKCFsZW5ndGgpIGxlbmd0aCA9IGk7XG5cbiAgdmFyIHJldCA9ICcnO1xuXG4gIGlmIChoYXNVdGYgPCAxMjgpIHtcbiAgICB2YXIgTUFYX0NIVU5LID0gMTAyNDsgLy8gc3BsaXQgdXAgaW50byBjaHVua3MsIGJlY2F1c2UgLmFwcGx5IG9uIGEgaHVnZSBzdHJpbmcgY2FuIG92ZXJmbG93IHRoZSBzdGFja1xuICAgIHZhciBjdXJyO1xuICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICBjdXJyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIEhFQVBVOC5zdWJhcnJheShwdHIsIHB0ciArIE1hdGgubWluKGxlbmd0aCwgTUFYX0NIVU5LKSkpO1xuICAgICAgcmV0ID0gcmV0ID8gcmV0ICsgY3VyciA6IGN1cnI7XG4gICAgICBwdHIgKz0gTUFYX0NIVU5LO1xuICAgICAgbGVuZ3RoIC09IE1BWF9DSFVOSztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICByZXR1cm4gVVRGOFRvU3RyaW5nKHB0cik7XG59XG5cbi8vIEdpdmVuIGEgcG9pbnRlciAncHRyJyB0byBhIG51bGwtdGVybWluYXRlZCBBU0NJSS1lbmNvZGVkIHN0cmluZyBpbiB0aGUgZW1zY3JpcHRlbiBIRUFQLCByZXR1cm5zXG4vLyBhIGNvcHkgb2YgdGhhdCBzdHJpbmcgYXMgYSBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXG5cbmZ1bmN0aW9uIEFzY2lpVG9TdHJpbmcocHRyKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgd2hpbGUgKDEpIHtcbiAgICB2YXIgY2ggPSBIRUFQOFsoKHB0cisrKT4+MCldO1xuICAgIGlmICghY2gpIHJldHVybiBzdHI7XG4gICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICB9XG59XG5cbi8vIENvcGllcyB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0ICdzdHInIHRvIHRoZSBlbXNjcmlwdGVuIEhFQVAgYXQgYWRkcmVzcyAnb3V0UHRyJyxcbi8vIG51bGwtdGVybWluYXRlZCBhbmQgZW5jb2RlZCBpbiBBU0NJSSBmb3JtLiBUaGUgY29weSB3aWxsIHJlcXVpcmUgYXQgbW9zdCBzdHIubGVuZ3RoKzEgYnl0ZXMgb2Ygc3BhY2UgaW4gdGhlIEhFQVAuXG5cbmZ1bmN0aW9uIHN0cmluZ1RvQXNjaWkoc3RyLCBvdXRQdHIpIHtcbiAgcmV0dXJuIHdyaXRlQXNjaWlUb01lbW9yeShzdHIsIG91dFB0ciwgZmFsc2UpO1xufVxuXG4vLyBHaXZlbiBhIHBvaW50ZXIgJ3B0cicgdG8gYSBudWxsLXRlcm1pbmF0ZWQgVVRGOC1lbmNvZGVkIHN0cmluZyBpbiB0aGUgZ2l2ZW4gYXJyYXkgdGhhdCBjb250YWlucyB1aW50OCB2YWx1ZXMsIHJldHVybnNcbi8vIGEgY29weSBvZiB0aGF0IHN0cmluZyBhcyBhIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdC5cblxudmFyIFVURjhEZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gVVRGOEFycmF5VG9TdHJpbmcodThBcnJheSwgaWR4KSB7XG4gIHZhciBlbmRQdHIgPSBpZHg7XG4gIC8vIFRleHREZWNvZGVyIG5lZWRzIHRvIGtub3cgdGhlIGJ5dGUgbGVuZ3RoIGluIGFkdmFuY2UsIGl0IGRvZXNuJ3Qgc3RvcCBvbiBudWxsIHRlcm1pbmF0b3IgYnkgaXRzZWxmLlxuICAvLyBBbHNvLCB1c2UgdGhlIGxlbmd0aCBpbmZvIHRvIGF2b2lkIHJ1bm5pbmcgdGlueSBzdHJpbmdzIHRocm91Z2ggVGV4dERlY29kZXIsIHNpbmNlIC5zdWJhcnJheSgpIGFsbG9jYXRlcyBnYXJiYWdlLlxuICB3aGlsZSAodThBcnJheVtlbmRQdHJdKSArK2VuZFB0cjtcblxuICBpZiAoZW5kUHRyIC0gaWR4ID4gMTYgJiYgdThBcnJheS5zdWJhcnJheSAmJiBVVEY4RGVjb2Rlcikge1xuICAgIHJldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUodThBcnJheS5zdWJhcnJheShpZHgsIGVuZFB0cikpO1xuICB9IGVsc2Uge1xuICAgIHZhciB1MCwgdTEsIHUyLCB1MywgdTQsIHU1O1xuXG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHdoaWxlICgxKSB7XG4gICAgICAvLyBGb3IgVVRGOCBieXRlIHN0cnVjdHVyZSwgc2VlOlxuICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuICAgICAgLy8gaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzIyNzkudHh0XG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzYyOVxuICAgICAgdTAgPSB1OEFycmF5W2lkeCsrXTtcbiAgICAgIGlmICghdTApIHJldHVybiBzdHI7XG4gICAgICBpZiAoISh1MCAmIDB4ODApKSB7IHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTsgY29udGludWU7IH1cbiAgICAgIHUxID0gdThBcnJheVtpZHgrK10gJiA2MztcbiAgICAgIGlmICgodTAgJiAweEUwKSA9PSAweEMwKSB7IHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgodTAgJiAzMSkgPDwgNikgfCB1MSk7IGNvbnRpbnVlOyB9XG4gICAgICB1MiA9IHU4QXJyYXlbaWR4KytdICYgNjM7XG4gICAgICBpZiAoKHUwICYgMHhGMCkgPT0gMHhFMCkge1xuICAgICAgICB1MCA9ICgodTAgJiAxNSkgPDwgMTIpIHwgKHUxIDw8IDYpIHwgdTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1MyA9IHU4QXJyYXlbaWR4KytdICYgNjM7XG4gICAgICAgIGlmICgodTAgJiAweEY4KSA9PSAweEYwKSB7XG4gICAgICAgICAgdTAgPSAoKHUwICYgNykgPDwgMTgpIHwgKHUxIDw8IDEyKSB8ICh1MiA8PCA2KSB8IHUzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHU0ID0gdThBcnJheVtpZHgrK10gJiA2MztcbiAgICAgICAgICBpZiAoKHUwICYgMHhGQykgPT0gMHhGOCkge1xuICAgICAgICAgICAgdTAgPSAoKHUwICYgMykgPDwgMjQpIHwgKHUxIDw8IDE4KSB8ICh1MiA8PCAxMikgfCAodTMgPDwgNikgfCB1NDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdTUgPSB1OEFycmF5W2lkeCsrXSAmIDYzO1xuICAgICAgICAgICAgdTAgPSAoKHUwICYgMSkgPDwgMzApIHwgKHUxIDw8IDI0KSB8ICh1MiA8PCAxOCkgfCAodTMgPDwgMTIpIHwgKHU0IDw8IDYpIHwgdTU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodTAgPCAweDEwMDAwKSB7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaCA9IHUwIC0gMHgxMDAwMDtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwIHwgKGNoID4+IDEwKSwgMHhEQzAwIHwgKGNoICYgMHgzRkYpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gR2l2ZW4gYSBwb2ludGVyICdwdHInIHRvIGEgbnVsbC10ZXJtaW5hdGVkIFVURjgtZW5jb2RlZCBzdHJpbmcgaW4gdGhlIGVtc2NyaXB0ZW4gSEVBUCwgcmV0dXJuc1xuLy8gYSBjb3B5IG9mIHRoYXQgc3RyaW5nIGFzIGEgSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0LlxuXG5mdW5jdGlvbiBVVEY4VG9TdHJpbmcocHRyKSB7XG4gIHJldHVybiBVVEY4QXJyYXlUb1N0cmluZyhIRUFQVTgscHRyKTtcbn1cblxuLy8gQ29waWVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QgJ3N0cicgdG8gdGhlIGdpdmVuIGJ5dGUgYXJyYXkgYXQgYWRkcmVzcyAnb3V0SWR4Jyxcbi8vIGVuY29kZWQgaW4gVVRGOCBmb3JtIGFuZCBudWxsLXRlcm1pbmF0ZWQuIFRoZSBjb3B5IHdpbGwgcmVxdWlyZSBhdCBtb3N0IHN0ci5sZW5ndGgqNCsxIGJ5dGVzIG9mIHNwYWNlIGluIHRoZSBIRUFQLlxuLy8gVXNlIHRoZSBmdW5jdGlvbiBsZW5ndGhCeXRlc1VURjggdG8gY29tcHV0ZSB0aGUgZXhhY3QgbnVtYmVyIG9mIGJ5dGVzIChleGNsdWRpbmcgbnVsbCB0ZXJtaW5hdG9yKSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCB3cml0ZS5cbi8vIFBhcmFtZXRlcnM6XG4vLyAgIHN0cjogdGhlIEphdmFzY3JpcHQgc3RyaW5nIHRvIGNvcHkuXG4vLyAgIG91dFU4QXJyYXk6IHRoZSBhcnJheSB0byBjb3B5IHRvLiBFYWNoIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgYXNzdW1lZCB0byBiZSBvbmUgOC1ieXRlIGVsZW1lbnQuXG4vLyAgIG91dElkeDogVGhlIHN0YXJ0aW5nIG9mZnNldCBpbiB0aGUgYXJyYXkgdG8gYmVnaW4gdGhlIGNvcHlpbmcuXG4vLyAgIG1heEJ5dGVzVG9Xcml0ZTogVGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHRoaXMgZnVuY3Rpb24gY2FuIHdyaXRlIHRvIHRoZSBhcnJheS5cbi8vICAgICAgICAgICAgICAgICAgICBUaGlzIGNvdW50IHNob3VsZCBpbmNsdWRlIHRoZSBudWxsIHRlcm1pbmF0b3IsXG4vLyAgICAgICAgICAgICAgICAgICAgaS5lLiBpZiBtYXhCeXRlc1RvV3JpdGU9MSwgb25seSB0aGUgbnVsbCB0ZXJtaW5hdG9yIHdpbGwgYmUgd3JpdHRlbiBhbmQgbm90aGluZyBlbHNlLlxuLy8gICAgICAgICAgICAgICAgICAgIG1heEJ5dGVzVG9Xcml0ZT0wIGRvZXMgbm90IHdyaXRlIGFueSBieXRlcyB0byB0aGUgb3V0cHV0LCBub3QgZXZlbiB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjhBcnJheShzdHIsIG91dFU4QXJyYXksIG91dElkeCwgbWF4Qnl0ZXNUb1dyaXRlKSB7XG4gIGlmICghKG1heEJ5dGVzVG9Xcml0ZSA+IDApKSAvLyBQYXJhbWV0ZXIgbWF4Qnl0ZXNUb1dyaXRlIGlzIG5vdCBvcHRpb25hbC4gTmVnYXRpdmUgdmFsdWVzLCAwLCBudWxsLCB1bmRlZmluZWQgYW5kIGZhbHNlIGVhY2ggZG9uJ3Qgd3JpdGUgb3V0IGFueSBieXRlcy5cbiAgICByZXR1cm4gMDtcblxuICB2YXIgc3RhcnRJZHggPSBvdXRJZHg7XG4gIHZhciBlbmRJZHggPSBvdXRJZHggKyBtYXhCeXRlc1RvV3JpdGUgLSAxOyAvLyAtMSBmb3Igc3RyaW5nIG51bGwgdGVybWluYXRvci5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBHb3RjaGE6IGNoYXJDb2RlQXQgcmV0dXJucyBhIDE2LWJpdCB3b3JkIHRoYXQgaXMgYSBVVEYtMTYgZW5jb2RlZCBjb2RlIHVuaXQsIG5vdCBhIFVuaWNvZGUgY29kZSBwb2ludCBvZiB0aGUgY2hhcmFjdGVyISBTbyBkZWNvZGUgVVRGMTYtPlVURjMyLT5VVEY4LlxuICAgIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvZmFxL3V0Zl9ib20uaHRtbCN1dGYxNi0zXG4gICAgLy8gRm9yIFVURjggYnl0ZSBzdHJ1Y3R1cmUsIHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uIGFuZCBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMjI3OS50eHQgYW5kIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNjI5XG4gICAgdmFyIHUgPSBzdHIuY2hhckNvZGVBdChpKTsgLy8gcG9zc2libHkgYSBsZWFkIHN1cnJvZ2F0ZVxuICAgIGlmICh1ID49IDB4RDgwMCAmJiB1IDw9IDB4REZGRikge1xuICAgICAgdmFyIHUxID0gc3RyLmNoYXJDb2RlQXQoKytpKTtcbiAgICAgIHUgPSAweDEwMDAwICsgKCh1ICYgMHgzRkYpIDw8IDEwKSB8ICh1MSAmIDB4M0ZGKTtcbiAgICB9XG4gICAgaWYgKHUgPD0gMHg3Rikge1xuICAgICAgaWYgKG91dElkeCA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSB1O1xuICAgIH0gZWxzZSBpZiAodSA8PSAweDdGRikge1xuICAgICAgaWYgKG91dElkeCArIDEgPj0gZW5kSWR4KSBicmVhaztcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHhDMCB8ICh1ID4+IDYpO1xuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XG4gICAgfSBlbHNlIGlmICh1IDw9IDB4RkZGRikge1xuICAgICAgaWYgKG91dElkeCArIDIgPj0gZW5kSWR4KSBicmVhaztcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHhFMCB8ICh1ID4+IDEyKTtcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDYzKTtcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICh1ICYgNjMpO1xuICAgIH0gZWxzZSBpZiAodSA8PSAweDFGRkZGRikge1xuICAgICAgaWYgKG91dElkeCArIDMgPj0gZW5kSWR4KSBicmVhaztcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHhGMCB8ICh1ID4+IDE4KTtcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiA2Myk7XG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiA2Myk7XG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICB9IGVsc2UgaWYgKHUgPD0gMHgzRkZGRkZGKSB7XG4gICAgICBpZiAob3V0SWR4ICsgNCA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweEY4IHwgKHUgPj4gMjQpO1xuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDE4KSAmIDYzKTtcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiA2Myk7XG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiA2Myk7XG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG91dElkeCArIDUgPj0gZW5kSWR4KSBicmVhaztcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHhGQyB8ICh1ID4+IDMwKTtcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAyNCkgJiA2Myk7XG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gMTgpICYgNjMpO1xuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDEyKSAmIDYzKTtcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDYzKTtcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICh1ICYgNjMpO1xuICAgIH1cbiAgfVxuICAvLyBOdWxsLXRlcm1pbmF0ZSB0aGUgcG9pbnRlciB0byB0aGUgYnVmZmVyLlxuICBvdXRVOEFycmF5W291dElkeF0gPSAwO1xuICByZXR1cm4gb3V0SWR4IC0gc3RhcnRJZHg7XG59XG5cbi8vIENvcGllcyB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0ICdzdHInIHRvIHRoZSBlbXNjcmlwdGVuIEhFQVAgYXQgYWRkcmVzcyAnb3V0UHRyJyxcbi8vIG51bGwtdGVybWluYXRlZCBhbmQgZW5jb2RlZCBpbiBVVEY4IGZvcm0uIFRoZSBjb3B5IHdpbGwgcmVxdWlyZSBhdCBtb3N0IHN0ci5sZW5ndGgqNCsxIGJ5dGVzIG9mIHNwYWNlIGluIHRoZSBIRUFQLlxuLy8gVXNlIHRoZSBmdW5jdGlvbiBsZW5ndGhCeXRlc1VURjggdG8gY29tcHV0ZSB0aGUgZXhhY3QgbnVtYmVyIG9mIGJ5dGVzIChleGNsdWRpbmcgbnVsbCB0ZXJtaW5hdG9yKSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCB3cml0ZS5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuLCBFWENMVURJTkcgdGhlIG51bGwgdGVybWluYXRvci5cblxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHtcbiAgcmV0dXJuIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgSEVBUFU4LG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKTtcbn1cblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IHN0cmluZyB0YWtlcyBpZiBlbmNvZGVkIGFzIGEgVVRGOCBieXRlIGFycmF5LCBFWENMVURJTkcgdGhlIG51bGwgdGVybWluYXRvciBieXRlLlxuXG5mdW5jdGlvbiBsZW5ndGhCeXRlc1VURjgoc3RyKSB7XG4gIHZhciBsZW4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIEdvdGNoYTogY2hhckNvZGVBdCByZXR1cm5zIGEgMTYtYml0IHdvcmQgdGhhdCBpcyBhIFVURi0xNiBlbmNvZGVkIGNvZGUgdW5pdCwgbm90IGEgVW5pY29kZSBjb2RlIHBvaW50IG9mIHRoZSBjaGFyYWN0ZXIhIFNvIGRlY29kZSBVVEYxNi0+VVRGMzItPlVURjguXG4gICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcbiAgICB2YXIgdSA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlXG4gICAgaWYgKHUgPj0gMHhEODAwICYmIHUgPD0gMHhERkZGKSB1ID0gMHgxMDAwMCArICgodSAmIDB4M0ZGKSA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4M0ZGKTtcbiAgICBpZiAodSA8PSAweDdGKSB7XG4gICAgICArK2xlbjtcbiAgICB9IGVsc2UgaWYgKHUgPD0gMHg3RkYpIHtcbiAgICAgIGxlbiArPSAyO1xuICAgIH0gZWxzZSBpZiAodSA8PSAweEZGRkYpIHtcbiAgICAgIGxlbiArPSAzO1xuICAgIH0gZWxzZSBpZiAodSA8PSAweDFGRkZGRikge1xuICAgICAgbGVuICs9IDQ7XG4gICAgfSBlbHNlIGlmICh1IDw9IDB4M0ZGRkZGRikge1xuICAgICAgbGVuICs9IDU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbiArPSA2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuO1xufVxuXG4vLyBHaXZlbiBhIHBvaW50ZXIgJ3B0cicgdG8gYSBudWxsLXRlcm1pbmF0ZWQgVVRGMTZMRS1lbmNvZGVkIHN0cmluZyBpbiB0aGUgZW1zY3JpcHRlbiBIRUFQLCByZXR1cm5zXG4vLyBhIGNvcHkgb2YgdGhhdCBzdHJpbmcgYXMgYSBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXG5cbnZhciBVVEYxNkRlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IFRleHREZWNvZGVyKCd1dGYtMTZsZScpIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gVVRGMTZUb1N0cmluZyhwdHIpIHtcbiAgdmFyIGVuZFB0ciA9IHB0cjtcbiAgLy8gVGV4dERlY29kZXIgbmVlZHMgdG8ga25vdyB0aGUgYnl0ZSBsZW5ndGggaW4gYWR2YW5jZSwgaXQgZG9lc24ndCBzdG9wIG9uIG51bGwgdGVybWluYXRvciBieSBpdHNlbGYuXG4gIC8vIEFsc28sIHVzZSB0aGUgbGVuZ3RoIGluZm8gdG8gYXZvaWQgcnVubmluZyB0aW55IHN0cmluZ3MgdGhyb3VnaCBUZXh0RGVjb2Rlciwgc2luY2UgLnN1YmFycmF5KCkgYWxsb2NhdGVzIGdhcmJhZ2UuXG4gIHZhciBpZHggPSBlbmRQdHIgPj4gMTtcbiAgd2hpbGUgKEhFQVAxNltpZHhdKSArK2lkeDtcbiAgZW5kUHRyID0gaWR4IDw8IDE7XG5cbiAgaWYgKGVuZFB0ciAtIHB0ciA+IDMyICYmIFVURjE2RGVjb2Rlcikge1xuICAgIHJldHVybiBVVEYxNkRlY29kZXIuZGVjb2RlKEhFQVBVOC5zdWJhcnJheShwdHIsIGVuZFB0cikpO1xuICB9IGVsc2Uge1xuICAgIHZhciBpID0gMDtcblxuICAgIHZhciBzdHIgPSAnJztcbiAgICB3aGlsZSAoMSkge1xuICAgICAgdmFyIGNvZGVVbml0ID0gSEVBUDE2WygoKHB0cikrKGkqMikpPj4xKV07XG4gICAgICBpZiAoY29kZVVuaXQgPT0gMCkgcmV0dXJuIHN0cjtcbiAgICAgICsraTtcbiAgICAgIC8vIGZyb21DaGFyQ29kZSBjb25zdHJ1Y3RzIGEgY2hhcmFjdGVyIGZyb20gYSBVVEYtMTYgY29kZSB1bml0LCBzbyB3ZSBjYW4gcGFzcyB0aGUgVVRGMTYgc3RyaW5nIHJpZ2h0IHRocm91Z2guXG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlVW5pdCk7XG4gICAgfVxuICB9XG59XG5cbi8vIENvcGllcyB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0ICdzdHInIHRvIHRoZSBlbXNjcmlwdGVuIEhFQVAgYXQgYWRkcmVzcyAnb3V0UHRyJyxcbi8vIG51bGwtdGVybWluYXRlZCBhbmQgZW5jb2RlZCBpbiBVVEYxNiBmb3JtLiBUaGUgY29weSB3aWxsIHJlcXVpcmUgYXQgbW9zdCBzdHIubGVuZ3RoKjQrMiBieXRlcyBvZiBzcGFjZSBpbiB0aGUgSEVBUC5cbi8vIFVzZSB0aGUgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYxNigpIHRvIGNvbXB1dGUgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyAoZXhjbHVkaW5nIG51bGwgdGVybWluYXRvcikgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgd3JpdGUuXG4vLyBQYXJhbWV0ZXJzOlxuLy8gICBzdHI6IHRoZSBKYXZhc2NyaXB0IHN0cmluZyB0byBjb3B5LlxuLy8gICBvdXRQdHI6IEJ5dGUgYWRkcmVzcyBpbiBFbXNjcmlwdGVuIEhFQVAgd2hlcmUgdG8gd3JpdGUgdGhlIHN0cmluZyB0by5cbi8vICAgbWF4Qnl0ZXNUb1dyaXRlOiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdGhpcyBmdW5jdGlvbiBjYW4gd3JpdGUgdG8gdGhlIGFycmF5LiBUaGlzIGNvdW50IHNob3VsZCBpbmNsdWRlIHRoZSBudWxsXG4vLyAgICAgICAgICAgICAgICAgICAgdGVybWluYXRvciwgaS5lLiBpZiBtYXhCeXRlc1RvV3JpdGU9Miwgb25seSB0aGUgbnVsbCB0ZXJtaW5hdG9yIHdpbGwgYmUgd3JpdHRlbiBhbmQgbm90aGluZyBlbHNlLlxuLy8gICAgICAgICAgICAgICAgICAgIG1heEJ5dGVzVG9Xcml0ZTwyIGRvZXMgbm90IHdyaXRlIGFueSBieXRlcyB0byB0aGUgb3V0cHV0LCBub3QgZXZlbiB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjE2KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHtcbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IGlmIG1heCBieXRlcyBpcyBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgdW5zYWZlIHVuYm91bmRlZCB3cml0ZSBpcyBhbGxvd2VkLlxuICBpZiAobWF4Qnl0ZXNUb1dyaXRlID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXhCeXRlc1RvV3JpdGUgPSAweDdGRkZGRkZGO1xuICB9XG4gIGlmIChtYXhCeXRlc1RvV3JpdGUgPCAyKSByZXR1cm4gMDtcbiAgbWF4Qnl0ZXNUb1dyaXRlIC09IDI7IC8vIE51bGwgdGVybWluYXRvci5cbiAgdmFyIHN0YXJ0UHRyID0gb3V0UHRyO1xuICB2YXIgbnVtQ2hhcnNUb1dyaXRlID0gKG1heEJ5dGVzVG9Xcml0ZSA8IHN0ci5sZW5ndGgqMikgPyAobWF4Qnl0ZXNUb1dyaXRlIC8gMikgOiBzdHIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNoYXJzVG9Xcml0ZTsgKytpKSB7XG4gICAgLy8gY2hhckNvZGVBdCByZXR1cm5zIGEgVVRGLTE2IGVuY29kZWQgY29kZSB1bml0LCBzbyBpdCBjYW4gYmUgZGlyZWN0bHkgd3JpdHRlbiB0byB0aGUgSEVBUC5cbiAgICB2YXIgY29kZVVuaXQgPSBzdHIuY2hhckNvZGVBdChpKTsgLy8gcG9zc2libHkgYSBsZWFkIHN1cnJvZ2F0ZVxuICAgIEhFQVAxNlsoKG91dFB0cik+PjEpXT1jb2RlVW5pdDtcbiAgICBvdXRQdHIgKz0gMjtcbiAgfVxuICAvLyBOdWxsLXRlcm1pbmF0ZSB0aGUgcG9pbnRlciB0byB0aGUgSEVBUC5cbiAgSEVBUDE2Wygob3V0UHRyKT4+MSldPTA7XG4gIHJldHVybiBvdXRQdHIgLSBzdGFydFB0cjtcbn1cblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IHN0cmluZyB0YWtlcyBpZiBlbmNvZGVkIGFzIGEgVVRGMTYgYnl0ZSBhcnJheSwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IgYnl0ZS5cblxuZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYxNihzdHIpIHtcbiAgcmV0dXJuIHN0ci5sZW5ndGgqMjtcbn1cblxuZnVuY3Rpb24gVVRGMzJUb1N0cmluZyhwdHIpIHtcbiAgdmFyIGkgPSAwO1xuXG4gIHZhciBzdHIgPSAnJztcbiAgd2hpbGUgKDEpIHtcbiAgICB2YXIgdXRmMzIgPSBIRUFQMzJbKCgocHRyKSsoaSo0KSk+PjIpXTtcbiAgICBpZiAodXRmMzIgPT0gMClcbiAgICAgIHJldHVybiBzdHI7XG4gICAgKytpO1xuICAgIC8vIEdvdGNoYTogZnJvbUNoYXJDb2RlIGNvbnN0cnVjdHMgYSBjaGFyYWN0ZXIgZnJvbSBhIFVURi0xNiBlbmNvZGVkIGNvZGUgKHBhaXIpLCBub3QgZnJvbSBhIFVuaWNvZGUgY29kZSBwb2ludCEgU28gZW5jb2RlIHRoZSBjb2RlIHBvaW50IHRvIFVURi0xNiBmb3IgY29uc3RydWN0aW5nLlxuICAgIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvZmFxL3V0Zl9ib20uaHRtbCN1dGYxNi0zXG4gICAgaWYgKHV0ZjMyID49IDB4MTAwMDApIHtcbiAgICAgIHZhciBjaCA9IHV0ZjMyIC0gMHgxMDAwMDtcbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCB8IChjaCA+PiAxMCksIDB4REMwMCB8IChjaCAmIDB4M0ZGKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHV0ZjMyKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gQ29waWVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QgJ3N0cicgdG8gdGhlIGVtc2NyaXB0ZW4gSEVBUCBhdCBhZGRyZXNzICdvdXRQdHInLFxuLy8gbnVsbC10ZXJtaW5hdGVkIGFuZCBlbmNvZGVkIGluIFVURjMyIGZvcm0uIFRoZSBjb3B5IHdpbGwgcmVxdWlyZSBhdCBtb3N0IHN0ci5sZW5ndGgqNCs0IGJ5dGVzIG9mIHNwYWNlIGluIHRoZSBIRUFQLlxuLy8gVXNlIHRoZSBmdW5jdGlvbiBsZW5ndGhCeXRlc1VURjMyKCkgdG8gY29tcHV0ZSB0aGUgZXhhY3QgbnVtYmVyIG9mIGJ5dGVzIChleGNsdWRpbmcgbnVsbCB0ZXJtaW5hdG9yKSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCB3cml0ZS5cbi8vIFBhcmFtZXRlcnM6XG4vLyAgIHN0cjogdGhlIEphdmFzY3JpcHQgc3RyaW5nIHRvIGNvcHkuXG4vLyAgIG91dFB0cjogQnl0ZSBhZGRyZXNzIGluIEVtc2NyaXB0ZW4gSEVBUCB3aGVyZSB0byB3cml0ZSB0aGUgc3RyaW5nIHRvLlxuLy8gICBtYXhCeXRlc1RvV3JpdGU6IFRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyB0aGlzIGZ1bmN0aW9uIGNhbiB3cml0ZSB0byB0aGUgYXJyYXkuIFRoaXMgY291bnQgc2hvdWxkIGluY2x1ZGUgdGhlIG51bGxcbi8vICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdG9yLCBpLmUuIGlmIG1heEJ5dGVzVG9Xcml0ZT00LCBvbmx5IHRoZSBudWxsIHRlcm1pbmF0b3Igd2lsbCBiZSB3cml0dGVuIGFuZCBub3RoaW5nIGVsc2UuXG4vLyAgICAgICAgICAgICAgICAgICAgbWF4Qnl0ZXNUb1dyaXRlPDQgZG9lcyBub3Qgd3JpdGUgYW55IGJ5dGVzIHRvIHRoZSBvdXRwdXQsIG5vdCBldmVuIHRoZSBudWxsIHRlcm1pbmF0b3IuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IuXG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGMzIoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkge1xuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaWYgbWF4IGJ5dGVzIGlzIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSB1bnNhZmUgdW5ib3VuZGVkIHdyaXRlIGlzIGFsbG93ZWQuXG4gIGlmIChtYXhCeXRlc1RvV3JpdGUgPT09IHVuZGVmaW5lZCkge1xuICAgIG1heEJ5dGVzVG9Xcml0ZSA9IDB4N0ZGRkZGRkY7XG4gIH1cbiAgaWYgKG1heEJ5dGVzVG9Xcml0ZSA8IDQpIHJldHVybiAwO1xuICB2YXIgc3RhcnRQdHIgPSBvdXRQdHI7XG4gIHZhciBlbmRQdHIgPSBzdGFydFB0ciArIG1heEJ5dGVzVG9Xcml0ZSAtIDQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gR290Y2hhOiBjaGFyQ29kZUF0IHJldHVybnMgYSAxNi1iaXQgd29yZCB0aGF0IGlzIGEgVVRGLTE2IGVuY29kZWQgY29kZSB1bml0LCBub3QgYSBVbmljb2RlIGNvZGUgcG9pbnQgb2YgdGhlIGNoYXJhY3RlciEgV2UgbXVzdCBkZWNvZGUgdGhlIHN0cmluZyB0byBVVEYtMzIgdG8gdGhlIGhlYXAuXG4gICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcbiAgICB2YXIgY29kZVVuaXQgPSBzdHIuY2hhckNvZGVBdChpKTsgLy8gcG9zc2libHkgYSBsZWFkIHN1cnJvZ2F0ZVxuICAgIGlmIChjb2RlVW5pdCA+PSAweEQ4MDAgJiYgY29kZVVuaXQgPD0gMHhERkZGKSB7XG4gICAgICB2YXIgdHJhaWxTdXJyb2dhdGUgPSBzdHIuY2hhckNvZGVBdCgrK2kpO1xuICAgICAgY29kZVVuaXQgPSAweDEwMDAwICsgKChjb2RlVW5pdCAmIDB4M0ZGKSA8PCAxMCkgfCAodHJhaWxTdXJyb2dhdGUgJiAweDNGRik7XG4gICAgfVxuICAgIEhFQVAzMlsoKG91dFB0cik+PjIpXT1jb2RlVW5pdDtcbiAgICBvdXRQdHIgKz0gNDtcbiAgICBpZiAob3V0UHRyICsgNCA+IGVuZFB0cikgYnJlYWs7XG4gIH1cbiAgLy8gTnVsbC10ZXJtaW5hdGUgdGhlIHBvaW50ZXIgdG8gdGhlIEhFQVAuXG4gIEhFQVAzMlsoKG91dFB0cik+PjIpXT0wO1xuICByZXR1cm4gb3V0UHRyIC0gc3RhcnRQdHI7XG59XG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBzdHJpbmcgdGFrZXMgaWYgZW5jb2RlZCBhcyBhIFVURjE2IGJ5dGUgYXJyYXksIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yIGJ5dGUuXG5cbmZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGMzIoc3RyKSB7XG4gIHZhciBsZW4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIEdvdGNoYTogY2hhckNvZGVBdCByZXR1cm5zIGEgMTYtYml0IHdvcmQgdGhhdCBpcyBhIFVURi0xNiBlbmNvZGVkIGNvZGUgdW5pdCwgbm90IGEgVW5pY29kZSBjb2RlIHBvaW50IG9mIHRoZSBjaGFyYWN0ZXIhIFdlIG11c3QgZGVjb2RlIHRoZSBzdHJpbmcgdG8gVVRGLTMyIHRvIHRoZSBoZWFwLlxuICAgIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvZmFxL3V0Zl9ib20uaHRtbCN1dGYxNi0zXG4gICAgdmFyIGNvZGVVbml0ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGVVbml0ID49IDB4RDgwMCAmJiBjb2RlVW5pdCA8PSAweERGRkYpICsraTsgLy8gcG9zc2libHkgYSBsZWFkIHN1cnJvZ2F0ZSwgc28gc2tpcCBvdmVyIHRoZSB0YWlsIHN1cnJvZ2F0ZS5cbiAgICBsZW4gKz0gNDtcbiAgfVxuXG4gIHJldHVybiBsZW47XG59XG5cbi8vIEFsbG9jYXRlIGhlYXAgc3BhY2UgZm9yIGEgSlMgc3RyaW5nLCBhbmQgd3JpdGUgaXQgdGhlcmUuXG4vLyBJdCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxlciB0byBmcmVlKCkgdGhhdCBtZW1vcnkuXG5mdW5jdGlvbiBhbGxvY2F0ZVVURjgoc3RyKSB7XG4gIHZhciBzaXplID0gbGVuZ3RoQnl0ZXNVVEY4KHN0cikgKyAxO1xuICB2YXIgcmV0ID0gX21hbGxvYyhzaXplKTtcbiAgaWYgKHJldCkgc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQOCwgcmV0LCBzaXplKTtcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQWxsb2NhdGUgc3RhY2sgc3BhY2UgZm9yIGEgSlMgc3RyaW5nLCBhbmQgd3JpdGUgaXQgdGhlcmUuXG5mdW5jdGlvbiBhbGxvY2F0ZVVURjhPblN0YWNrKHN0cikge1xuICB2YXIgc2l6ZSA9IGxlbmd0aEJ5dGVzVVRGOChzdHIpICsgMTtcbiAgdmFyIHJldCA9IHN0YWNrQWxsb2Moc2l6ZSk7XG4gIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgSEVBUDgsIHJldCwgc2l6ZSk7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRlbWFuZ2xlKGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmM7XG59XG5cbmZ1bmN0aW9uIGRlbWFuZ2xlQWxsKHRleHQpIHtcbiAgdmFyIHJlZ2V4ID1cbiAgICAvX19aW1xcd1xcZF9dKy9nO1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlZ2V4LFxuICAgIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciB5ID0gZGVtYW5nbGUoeCk7XG4gICAgICByZXR1cm4geCA9PT0geSA/IHggOiAoeSArICcgWycgKyB4ICsgJ10nKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24ganNTdGFja1RyYWNlKCkge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gIGlmICghZXJyLnN0YWNrKSB7XG4gICAgLy8gSUUxMCsgc3BlY2lhbCBjYXNlczogSXQgZG9lcyBoYXZlIGNhbGxzdGFjayBpbmZvLCBidXQgaXQgaXMgb25seSBwb3B1bGF0ZWQgaWYgYW4gRXJyb3Igb2JqZWN0IGlzIHRocm93bixcbiAgICAvLyBzbyB0cnkgdGhhdCBhcyBhIHNwZWNpYWwtY2FzZS5cbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKDApO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9XG4gICAgaWYgKCFlcnIuc3RhY2spIHtcbiAgICAgIHJldHVybiAnKG5vIHN0YWNrIHRyYWNlIGF2YWlsYWJsZSknO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXJyLnN0YWNrLnRvU3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIHN0YWNrVHJhY2UoKSB7XG4gIHZhciBqcyA9IGpzU3RhY2tUcmFjZSgpO1xuICBpZiAoTW9kdWxlWydleHRyYVN0YWNrVHJhY2UnXSkganMgKz0gJ1xcbicgKyBNb2R1bGVbJ2V4dHJhU3RhY2tUcmFjZSddKCk7XG4gIHJldHVybiBkZW1hbmdsZUFsbChqcyk7XG59XG5cbi8vIE1lbW9yeSBtYW5hZ2VtZW50XG5cbnZhciBQQUdFX1NJWkUgPSAxNjM4NDtcbnZhciBXQVNNX1BBR0VfU0laRSA9IDY1NTM2O1xudmFyIEFTTUpTX1BBR0VfU0laRSA9IDE2Nzc3MjE2O1xudmFyIE1JTl9UT1RBTF9NRU1PUlkgPSAxNjc3NzIxNjtcblxuZnVuY3Rpb24gYWxpZ25VcCh4LCBtdWx0aXBsZSkge1xuICBpZiAoeCAlIG11bHRpcGxlID4gMCkge1xuICAgIHggKz0gbXVsdGlwbGUgLSAoeCAlIG11bHRpcGxlKTtcbiAgfVxuICByZXR1cm4geDtcbn1cblxudmFyIEhFQVAsXG4vKiogQHR5cGUge0FycmF5QnVmZmVyfSAqL1xuICBidWZmZXIsXG4vKiogQHR5cGUge0ludDhBcnJheX0gKi9cbiAgSEVBUDgsXG4vKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovXG4gIEhFQVBVOCxcbi8qKiBAdHlwZSB7SW50MTZBcnJheX0gKi9cbiAgSEVBUDE2LFxuLyoqIEB0eXBlIHtVaW50MTZBcnJheX0gKi9cbiAgSEVBUFUxNixcbi8qKiBAdHlwZSB7SW50MzJBcnJheX0gKi9cbiAgSEVBUDMyLFxuLyoqIEB0eXBlIHtVaW50MzJBcnJheX0gKi9cbiAgSEVBUFUzMixcbi8qKiBAdHlwZSB7RmxvYXQzMkFycmF5fSAqL1xuICBIRUFQRjMyLFxuLyoqIEB0eXBlIHtGbG9hdDY0QXJyYXl9ICovXG4gIEhFQVBGNjQ7XG5cbmZ1bmN0aW9uIHVwZGF0ZUdsb2JhbEJ1ZmZlcihidWYpIHtcbiAgTW9kdWxlWydidWZmZXInXSA9IGJ1ZmZlciA9IGJ1Zjtcbn1cblxuZnVuY3Rpb24gdXBkYXRlR2xvYmFsQnVmZmVyVmlld3MoKSB7XG4gIE1vZHVsZVsnSEVBUDgnXSA9IEhFQVA4ID0gbmV3IEludDhBcnJheShidWZmZXIpO1xuICBNb2R1bGVbJ0hFQVAxNiddID0gSEVBUDE2ID0gbmV3IEludDE2QXJyYXkoYnVmZmVyKTtcbiAgTW9kdWxlWydIRUFQMzInXSA9IEhFQVAzMiA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7XG4gIE1vZHVsZVsnSEVBUFU4J10gPSBIRUFQVTggPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICBNb2R1bGVbJ0hFQVBVMTYnXSA9IEhFQVBVMTYgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyKTtcbiAgTW9kdWxlWydIRUFQVTMyJ10gPSBIRUFQVTMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gIE1vZHVsZVsnSEVBUEYzMiddID0gSEVBUEYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbiAgTW9kdWxlWydIRUFQRjY0J10gPSBIRUFQRjY0ID0gbmV3IEZsb2F0NjRBcnJheShidWZmZXIpO1xufVxuXG52YXIgU1RBVElDX0JBU0UsIFNUQVRJQ1RPUCwgc3RhdGljU2VhbGVkOyAvLyBzdGF0aWMgYXJlYVxudmFyIFNUQUNLX0JBU0UsIFNUQUNLVE9QLCBTVEFDS19NQVg7IC8vIHN0YWNrIGFyZWFcbnZhciBEWU5BTUlDX0JBU0UsIERZTkFNSUNUT1BfUFRSOyAvLyBkeW5hbWljIGFyZWEgaGFuZGxlZCBieSBzYnJrXG5cbiAgU1RBVElDX0JBU0UgPSBTVEFUSUNUT1AgPSBTVEFDS19CQVNFID0gU1RBQ0tUT1AgPSBTVEFDS19NQVggPSBEWU5BTUlDX0JBU0UgPSBEWU5BTUlDVE9QX1BUUiA9IDA7XG4gIHN0YXRpY1NlYWxlZCA9IGZhbHNlO1xuXG5cblxuXG5mdW5jdGlvbiBhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeSgpIHtcbiAgYWJvcnQoJ0Nhbm5vdCBlbmxhcmdlIG1lbW9yeSBhcnJheXMuIEVpdGhlciAoMSkgY29tcGlsZSB3aXRoICAtcyBUT1RBTF9NRU1PUlk9WCAgd2l0aCBYIGhpZ2hlciB0aGFuIHRoZSBjdXJyZW50IHZhbHVlICcgKyBUT1RBTF9NRU1PUlkgKyAnLCAoMikgY29tcGlsZSB3aXRoICAtcyBBTExPV19NRU1PUllfR1JPV1RIPTEgIHdoaWNoIGFsbG93cyBpbmNyZWFzaW5nIHRoZSBzaXplIGF0IHJ1bnRpbWUsIG9yICgzKSBpZiB5b3Ugd2FudCBtYWxsb2MgdG8gcmV0dXJuIE5VTEwgKDApIGluc3RlYWQgb2YgdGhpcyBhYm9ydCwgY29tcGlsZSB3aXRoICAtcyBBQk9SVElOR19NQUxMT0M9MCAnKTtcbn1cblxuXG5mdW5jdGlvbiBlbmxhcmdlTWVtb3J5KCkge1xuICBhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeSgpO1xufVxuXG5cbnZhciBUT1RBTF9TVEFDSyA9IE1vZHVsZVsnVE9UQUxfU1RBQ0snXSB8fCA1MjQyODgwO1xudmFyIFRPVEFMX01FTU9SWSA9IE1vZHVsZVsnVE9UQUxfTUVNT1JZJ10gfHwgMTY3NzcyMTY7XG5pZiAoVE9UQUxfTUVNT1JZIDwgVE9UQUxfU1RBQ0spIGVycignVE9UQUxfTUVNT1JZIHNob3VsZCBiZSBsYXJnZXIgdGhhbiBUT1RBTF9TVEFDSywgd2FzICcgKyBUT1RBTF9NRU1PUlkgKyAnISAoVE9UQUxfU1RBQ0s9JyArIFRPVEFMX1NUQUNLICsgJyknKTtcblxuLy8gSW5pdGlhbGl6ZSB0aGUgcnVudGltZSdzIG1lbW9yeVxuXG5cblxuLy8gVXNlIGEgcHJvdmlkZWQgYnVmZmVyLCBpZiB0aGVyZSBpcyBvbmUsIG9yIGVsc2UgYWxsb2NhdGUgYSBuZXcgb25lXG5pZiAoTW9kdWxlWydidWZmZXInXSkge1xuICBidWZmZXIgPSBNb2R1bGVbJ2J1ZmZlciddO1xufSBlbHNlIHtcbiAgLy8gVXNlIGEgV2ViQXNzZW1ibHkgbWVtb3J5IHdoZXJlIGF2YWlsYWJsZVxuICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgV2ViQXNzZW1ibHkuTWVtb3J5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgTW9kdWxlWyd3YXNtTWVtb3J5J10gPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHsgJ2luaXRpYWwnOiBUT1RBTF9NRU1PUlkgLyBXQVNNX1BBR0VfU0laRSwgJ21heGltdW0nOiBUT1RBTF9NRU1PUlkgLyBXQVNNX1BBR0VfU0laRSB9KTtcbiAgICBidWZmZXIgPSBNb2R1bGVbJ3dhc21NZW1vcnknXS5idWZmZXI7XG4gIH0gZWxzZVxuICB7XG4gICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKFRPVEFMX01FTU9SWSk7XG4gIH1cbiAgTW9kdWxlWydidWZmZXInXSA9IGJ1ZmZlcjtcbn1cbnVwZGF0ZUdsb2JhbEJ1ZmZlclZpZXdzKCk7XG5cblxuZnVuY3Rpb24gZ2V0VG90YWxNZW1vcnkoKSB7XG4gIHJldHVybiBUT1RBTF9NRU1PUlk7XG59XG5cbi8vIEVuZGlhbm5lc3MgY2hlY2sgKG5vdGU6IGFzc3VtZXMgY29tcGlsZXIgYXJjaCB3YXMgbGl0dGxlLWVuZGlhbilcblxuZnVuY3Rpb24gY2FsbFJ1bnRpbWVDYWxsYmFja3MoY2FsbGJhY2tzKSB7XG4gIHdoaWxlKGNhbGxiYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzLnNoaWZ0KCk7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBmdW5jID0gY2FsbGJhY2suZnVuYztcbiAgICBpZiAodHlwZW9mIGZ1bmMgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoY2FsbGJhY2suYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgTW9kdWxlWydkeW5DYWxsX3YnXShmdW5jKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE1vZHVsZVsnZHluQ2FsbF92aSddKGZ1bmMsIGNhbGxiYWNrLmFyZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bmMoY2FsbGJhY2suYXJnID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2suYXJnKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIF9fQVRQUkVSVU5fXyAgPSBbXTsgLy8gZnVuY3Rpb25zIGNhbGxlZCBiZWZvcmUgdGhlIHJ1bnRpbWUgaXMgaW5pdGlhbGl6ZWRcbnZhciBfX0FUSU5JVF9fICAgID0gW107IC8vIGZ1bmN0aW9ucyBjYWxsZWQgZHVyaW5nIHN0YXJ0dXBcbnZhciBfX0FUTUFJTl9fICAgID0gW107IC8vIGZ1bmN0aW9ucyBjYWxsZWQgd2hlbiBtYWluKCkgaXMgdG8gYmUgcnVuXG52YXIgX19BVEVYSVRfXyAgICA9IFtdOyAvLyBmdW5jdGlvbnMgY2FsbGVkIGR1cmluZyBzaHV0ZG93blxudmFyIF9fQVRQT1NUUlVOX18gPSBbXTsgLy8gZnVuY3Rpb25zIGNhbGxlZCBhZnRlciB0aGUgbWFpbigpIGlzIGNhbGxlZFxuXG52YXIgcnVudGltZUluaXRpYWxpemVkID0gZmFsc2U7XG52YXIgcnVudGltZUV4aXRlZCA9IGZhbHNlO1xuXG5cbmZ1bmN0aW9uIHByZVJ1bigpIHtcbiAgLy8gY29tcGF0aWJpbGl0eSAtIG1lcmdlIGluIGFueXRoaW5nIGZyb20gTW9kdWxlWydwcmVSdW4nXSBhdCB0aGlzIHRpbWVcbiAgaWYgKE1vZHVsZVsncHJlUnVuJ10pIHtcbiAgICBpZiAodHlwZW9mIE1vZHVsZVsncHJlUnVuJ10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwcmVSdW4nXSA9IFtNb2R1bGVbJ3ByZVJ1biddXTtcbiAgICB3aGlsZSAoTW9kdWxlWydwcmVSdW4nXS5sZW5ndGgpIHtcbiAgICAgIGFkZE9uUHJlUnVuKE1vZHVsZVsncHJlUnVuJ10uc2hpZnQoKSk7XG4gICAgfVxuICB9XG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyk7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUluaXRSdW50aW1lKCkge1xuICBpZiAocnVudGltZUluaXRpYWxpemVkKSByZXR1cm47XG4gIHJ1bnRpbWVJbml0aWFsaXplZCA9IHRydWU7XG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRJTklUX18pO1xufVxuXG5mdW5jdGlvbiBwcmVNYWluKCkge1xuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUTUFJTl9fKTtcbn1cblxuZnVuY3Rpb24gZXhpdFJ1bnRpbWUoKSB7XG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRFWElUX18pO1xuICBydW50aW1lRXhpdGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcG9zdFJ1bigpIHtcbiAgLy8gY29tcGF0aWJpbGl0eSAtIG1lcmdlIGluIGFueXRoaW5nIGZyb20gTW9kdWxlWydwb3N0UnVuJ10gYXQgdGhpcyB0aW1lXG4gIGlmIChNb2R1bGVbJ3Bvc3RSdW4nXSkge1xuICAgIGlmICh0eXBlb2YgTW9kdWxlWydwb3N0UnVuJ10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwb3N0UnVuJ10gPSBbTW9kdWxlWydwb3N0UnVuJ11dO1xuICAgIHdoaWxlIChNb2R1bGVbJ3Bvc3RSdW4nXS5sZW5ndGgpIHtcbiAgICAgIGFkZE9uUG9zdFJ1bihNb2R1bGVbJ3Bvc3RSdW4nXS5zaGlmdCgpKTtcbiAgICB9XG4gIH1cbiAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyk7XG59XG5cbmZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKSB7XG4gIF9fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKTtcbn1cblxuZnVuY3Rpb24gYWRkT25Jbml0KGNiKSB7XG4gIF9fQVRJTklUX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uUHJlTWFpbihjYikge1xuICBfX0FUTUFJTl9fLnVuc2hpZnQoY2IpO1xufVxuXG5mdW5jdGlvbiBhZGRPbkV4aXQoY2IpIHtcbiAgX19BVEVYSVRfXy51bnNoaWZ0KGNiKTtcbn1cblxuZnVuY3Rpb24gYWRkT25Qb3N0UnVuKGNiKSB7XG4gIF9fQVRQT1NUUlVOX18udW5zaGlmdChjYik7XG59XG5cbi8vIERlcHJlY2F0ZWQ6IFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVjYXVzZSBpdCBpcyB1bnNhZmUgYW5kIGRvZXMgbm90IHByb3ZpZGVcbi8vIGEgbWF4aW11bSBsZW5ndGggbGltaXQgb2YgaG93IG1hbnkgYnl0ZXMgaXQgaXMgYWxsb3dlZCB0byB3cml0ZS4gUHJlZmVyIGNhbGxpbmcgdGhlXG4vLyBmdW5jdGlvbiBzdHJpbmdUb1VURjhBcnJheSgpIGluc3RlYWQsIHdoaWNoIHRha2VzIGluIGEgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgdXNlZFxuLy8gdG8gYmUgc2VjdXJlIGZyb20gb3V0IG9mIGJvdW5kcyB3cml0ZXMuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nVG9NZW1vcnkoc3RyaW5nLCBidWZmZXIsIGRvbnRBZGROdWxsKSB7XG4gIHdhcm5PbmNlKCd3cml0ZVN0cmluZ1RvTWVtb3J5IGlzIGRlcHJlY2F0ZWQgYW5kIHNob3VsZCBub3QgYmUgY2FsbGVkISBVc2Ugc3RyaW5nVG9VVEY4KCkgaW5zdGVhZCEnKTtcblxuICB2YXIgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGxhc3RDaGFyLCAvKiogQHR5cGUge251bWJlcn0gKi8gZW5kO1xuICBpZiAoZG9udEFkZE51bGwpIHtcbiAgICAvLyBzdHJpbmdUb1VURjhBcnJheSBhbHdheXMgYXBwZW5kcyBudWxsLiBJZiB3ZSBkb24ndCB3YW50IHRvIGRvIHRoYXQsIHJlbWVtYmVyIHRoZVxuICAgIC8vIGNoYXJhY3RlciB0aGF0IGV4aXN0ZWQgYXQgdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBudWxsIHdpbGwgYmUgcGxhY2VkLCBhbmQgcmVzdG9yZVxuICAgIC8vIHRoYXQgYWZ0ZXIgdGhlIHdyaXRlIChiZWxvdykuXG4gICAgZW5kID0gYnVmZmVyICsgbGVuZ3RoQnl0ZXNVVEY4KHN0cmluZyk7XG4gICAgbGFzdENoYXIgPSBIRUFQOFtlbmRdO1xuICB9XG4gIHN0cmluZ1RvVVRGOChzdHJpbmcsIGJ1ZmZlciwgSW5maW5pdHkpO1xuICBpZiAoZG9udEFkZE51bGwpIEhFQVA4W2VuZF0gPSBsYXN0Q2hhcjsgLy8gUmVzdG9yZSB0aGUgdmFsdWUgdW5kZXIgdGhlIG51bGwgY2hhcmFjdGVyLlxufVxuXG5mdW5jdGlvbiB3cml0ZUFycmF5VG9NZW1vcnkoYXJyYXksIGJ1ZmZlcikge1xuICBIRUFQOC5zZXQoYXJyYXksIGJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQXNjaWlUb01lbW9yeShzdHIsIGJ1ZmZlciwgZG9udEFkZE51bGwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBIRUFQOFsoKGJ1ZmZlcisrKT4+MCldPXN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIC8vIE51bGwtdGVybWluYXRlIHRoZSBwb2ludGVyIHRvIHRoZSBIRUFQLlxuICBpZiAoIWRvbnRBZGROdWxsKSBIRUFQOFsoKGJ1ZmZlcik+PjApXT0wO1xufVxuXG5mdW5jdGlvbiB1blNpZ24odmFsdWUsIGJpdHMsIGlnbm9yZSkge1xuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gYml0cyA8PSAzMiA/IDIqTWF0aC5hYnMoMSA8PCAoYml0cy0xKSkgKyB2YWx1ZSAvLyBOZWVkIHNvbWUgdHJpY2tlcnksIHNpbmNlIGlmIGJpdHMgPT0gMzIsIHdlIGFyZSByaWdodCBhdCB0aGUgbGltaXQgb2YgdGhlIGJpdHMgSlMgdXNlcyBpbiBiaXRzaGlmdHNcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLnBvdygyLCBiaXRzKSAgICAgICAgICsgdmFsdWU7XG59XG5mdW5jdGlvbiByZVNpZ24odmFsdWUsIGJpdHMsIGlnbm9yZSkge1xuICBpZiAodmFsdWUgPD0gMCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaGFsZiA9IGJpdHMgPD0gMzIgPyBNYXRoLmFicygxIDw8IChiaXRzLTEpKSAvLyBhYnMgaXMgbmVlZGVkIGlmIGJpdHMgPT0gMzJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5wb3coMiwgYml0cy0xKTtcbiAgaWYgKHZhbHVlID49IGhhbGYgJiYgKGJpdHMgPD0gMzIgfHwgdmFsdWUgPiBoYWxmKSkgeyAvLyBmb3IgaHVnZSB2YWx1ZXMsIHdlIGNhbiBoaXQgdGhlIHByZWNpc2lvbiBsaW1pdCBhbmQgYWx3YXlzIGdldCB0cnVlIGhlcmUuIHNvIGRvbid0IGRvIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQsIGluIGdlbmVyYWwgdGhlcmUgaXMgbm8gcGVyZmVjdCBzb2x1dGlvbiBoZXJlLiBXaXRoIDY0LWJpdCBpbnRzLCB3ZSBnZXQgcm91bmRpbmcgYW5kIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEluIGk2NCBtb2RlIDEsIHJlc2lnbiB0aGUgdHdvIHBhcnRzIHNlcGFyYXRlbHkgYW5kIHNhZmVseVxuICAgIHZhbHVlID0gLTIqaGFsZiArIHZhbHVlOyAvLyBDYW5ub3QgYml0c2hpZnQgaGFsZiwgYXMgaXQgbWF5IGJlIGF0IHRoZSBsaW1pdCBvZiB0aGUgYml0cyBKUyB1c2VzIGluIGJpdHNoaWZ0c1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuXG52YXIgTWF0aF9hYnMgPSBNYXRoLmFicztcbnZhciBNYXRoX2NvcyA9IE1hdGguY29zO1xudmFyIE1hdGhfc2luID0gTWF0aC5zaW47XG52YXIgTWF0aF90YW4gPSBNYXRoLnRhbjtcbnZhciBNYXRoX2Fjb3MgPSBNYXRoLmFjb3M7XG52YXIgTWF0aF9hc2luID0gTWF0aC5hc2luO1xudmFyIE1hdGhfYXRhbiA9IE1hdGguYXRhbjtcbnZhciBNYXRoX2F0YW4yID0gTWF0aC5hdGFuMjtcbnZhciBNYXRoX2V4cCA9IE1hdGguZXhwO1xudmFyIE1hdGhfbG9nID0gTWF0aC5sb2c7XG52YXIgTWF0aF9zcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIE1hdGhfY2VpbCA9IE1hdGguY2VpbDtcbnZhciBNYXRoX2Zsb29yID0gTWF0aC5mbG9vcjtcbnZhciBNYXRoX3BvdyA9IE1hdGgucG93O1xudmFyIE1hdGhfaW11bCA9IE1hdGguaW11bDtcbnZhciBNYXRoX2Zyb3VuZCA9IE1hdGguZnJvdW5kO1xudmFyIE1hdGhfcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIE1hdGhfbWluID0gTWF0aC5taW47XG52YXIgTWF0aF9tYXggPSBNYXRoLm1heDtcbnZhciBNYXRoX2NsejMyID0gTWF0aC5jbHozMjtcbnZhciBNYXRoX3RydW5jID0gTWF0aC50cnVuYztcblxuLy8gQSBjb3VudGVyIG9mIGRlcGVuZGVuY2llcyBmb3IgY2FsbGluZyBydW4oKS4gSWYgd2UgbmVlZCB0b1xuLy8gZG8gYXN5bmNocm9ub3VzIHdvcmsgYmVmb3JlIHJ1bm5pbmcsIGluY3JlbWVudCB0aGlzIGFuZFxuLy8gZGVjcmVtZW50IGl0LiBJbmNyZW1lbnRpbmcgbXVzdCBoYXBwZW4gaW4gYSBwbGFjZSBsaWtlXG4vLyBNb2R1bGUucHJlUnVuICh1c2VkIGJ5IGVtY2MgdG8gYWRkIGZpbGUgcHJlbG9hZGluZykuXG4vLyBOb3RlIHRoYXQgeW91IGNhbiBhZGQgZGVwZW5kZW5jaWVzIGluIHByZVJ1biwgZXZlbiB0aG91Z2hcbi8vIGl0IGhhcHBlbnMgcmlnaHQgYmVmb3JlIHJ1biAtIHJ1biB3aWxsIGJlIHBvc3Rwb25lZCB1bnRpbFxuLy8gdGhlIGRlcGVuZGVuY2llcyBhcmUgbWV0LlxudmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7XG52YXIgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xudmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7IC8vIG92ZXJyaWRkZW4gdG8gdGFrZSBkaWZmZXJlbnQgYWN0aW9ucyB3aGVuIGFsbCBydW4gZGVwZW5kZW5jaWVzIGFyZSBmdWxmaWxsZWRcblxuZnVuY3Rpb24gZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeShpZCkge1xuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpIHtcbiAgcnVuRGVwZW5kZW5jaWVzKys7XG4gIGlmIChNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkge1xuICAgIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKHJ1bkRlcGVuZGVuY2llcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCkge1xuICBydW5EZXBlbmRlbmNpZXMtLTtcbiAgaWYgKE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKSB7XG4gICAgTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10ocnVuRGVwZW5kZW5jaWVzKTtcbiAgfVxuICBpZiAocnVuRGVwZW5kZW5jaWVzID09IDApIHtcbiAgICBpZiAocnVuRGVwZW5kZW5jeVdhdGNoZXIgIT09IG51bGwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xuICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ7XG4gICAgICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuICAgICAgY2FsbGJhY2soKTsgLy8gY2FuIGFkZCBhbm90aGVyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZFxuICAgIH1cbiAgfVxufVxuXG5Nb2R1bGVbXCJwcmVsb2FkZWRJbWFnZXNcIl0gPSB7fTsgLy8gbWFwcyB1cmwgdG8gaW1hZ2UgZGF0YVxuTW9kdWxlW1wicHJlbG9hZGVkQXVkaW9zXCJdID0ge307IC8vIG1hcHMgdXJsIHRvIGF1ZGlvIGRhdGFcblxuXG5cbnZhciBtZW1vcnlJbml0aWFsaXplciA9IG51bGw7XG5cblxuXG5cblxuXG4vLyBDb3B5cmlnaHQgMjAxNyBUaGUgRW1zY3JpcHRlbiBBdXRob3JzLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIEVtc2NyaXB0ZW4gaXMgYXZhaWxhYmxlIHVuZGVyIHR3byBzZXBhcmF0ZSBsaWNlbnNlcywgdGhlIE1JVCBsaWNlbnNlIGFuZCB0aGVcbi8vIFVuaXZlcnNpdHkgb2YgSWxsaW5vaXMvTkNTQSBPcGVuIFNvdXJjZSBMaWNlbnNlLiAgQm90aCB0aGVzZSBsaWNlbnNlcyBjYW4gYmVcbi8vIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG5cbi8vIFByZWZpeCBvZiBkYXRhIFVSSXMgZW1pdHRlZCBieSBTSU5HTEVfRklMRSBhbmQgcmVsYXRlZCBvcHRpb25zLlxudmFyIGRhdGFVUklQcmVmaXggPSAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCc7XG5cbi8vIEluZGljYXRlcyB3aGV0aGVyIGZpbGVuYW1lIGlzIGEgYmFzZTY0IGRhdGEgVVJJLlxuZnVuY3Rpb24gaXNEYXRhVVJJKGZpbGVuYW1lKSB7XG4gIHJldHVybiBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggP1xuICAgICAgZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KSA6XG4gICAgICBmaWxlbmFtZS5pbmRleE9mKGRhdGFVUklQcmVmaXgpID09PSAwO1xufVxuXG5cblxuXG5mdW5jdGlvbiBpbnRlZ3JhdGVXYXNtSlMoKSB7XG4gIC8vIHdhc20uanMgaGFzIHNldmVyYWwgbWV0aG9kcyBmb3IgY3JlYXRpbmcgdGhlIGNvbXBpbGVkIGNvZGUgbW9kdWxlIGhlcmU6XG4gIC8vICAqICduYXRpdmUtd2FzbScgOiB1c2UgbmF0aXZlIFdlYkFzc2VtYmx5IHN1cHBvcnQgaW4gdGhlIGJyb3dzZXJcbiAgLy8gICogJ2ludGVycHJldC1zLWV4cHInOiBsb2FkIHMtZXhwcmVzc2lvbiBjb2RlIGZyb20gYSAud2FzdCBhbmQgaW50ZXJwcmV0XG4gIC8vICAqICdpbnRlcnByZXQtYmluYXJ5JzogbG9hZCBiaW5hcnkgd2FzbSBhbmQgaW50ZXJwcmV0XG4gIC8vICAqICdpbnRlcnByZXQtYXNtMndhc20nOiBsb2FkIGFzbS5qcyBjb2RlLCB0cmFuc2xhdGUgdG8gd2FzbSwgYW5kIGludGVycHJldFxuICAvLyAgKiAnYXNtanMnOiBubyB3YXNtLCBqdXN0IGxvYWQgdGhlIGFzbS5qcyBjb2RlIGFuZCB1c2UgdGhhdCAoZ29vZCBmb3IgdGVzdGluZylcbiAgLy8gVGhlIG1ldGhvZCBpcyBzZXQgYXQgY29tcGlsZSB0aW1lIChCSU5BUllFTl9NRVRIT0QpXG4gIC8vIFRoZSBtZXRob2QgY2FuIGJlIGEgY29tbWEtc2VwYXJhdGVkIGxpc3QsIGluIHdoaWNoIGNhc2UsIHdlIHdpbGwgdHJ5IHRoZVxuICAvLyBvcHRpb25zIG9uZSBieSBvbmUuIFNvbWUgb2YgdGhlbSBjYW4gZmFpbCBncmFjZWZ1bGx5LCBhbmQgdGhlbiB3ZSBjYW4gdHJ5XG4gIC8vIHRoZSBuZXh0LlxuXG4gIC8vIGlucHV0c1xuXG4gIHZhciBtZXRob2QgPSAnbmF0aXZlLXdhc20nO1xuXG4gIHZhciB3YXNtVGV4dEZpbGUgPSAnZmFzdC1zb3VuZC53YXN0JztcbiAgdmFyIHdhc21CaW5hcnlGaWxlID0gJ2Zhc3Qtc291bmQud2FzbSc7XG4gIHZhciBhc21qc0NvZGVGaWxlID0gJ2Zhc3Qtc291bmQudGVtcC5hc20uanMnO1xuXG4gIGlmICghaXNEYXRhVVJJKHdhc21UZXh0RmlsZSkpIHtcbiAgICB3YXNtVGV4dEZpbGUgPSBsb2NhdGVGaWxlKHdhc21UZXh0RmlsZSk7XG4gIH1cbiAgaWYgKCFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpKSB7XG4gICAgd2FzbUJpbmFyeUZpbGUgPSBsb2NhdGVGaWxlKHdhc21CaW5hcnlGaWxlKTtcbiAgfVxuICBpZiAoIWlzRGF0YVVSSShhc21qc0NvZGVGaWxlKSkge1xuICAgIGFzbWpzQ29kZUZpbGUgPSBsb2NhdGVGaWxlKGFzbWpzQ29kZUZpbGUpO1xuICB9XG5cbiAgLy8gdXRpbGl0aWVzXG5cbiAgdmFyIHdhc21QYWdlU2l6ZSA9IDY0KjEwMjQ7XG5cbiAgdmFyIGluZm8gPSB7XG4gICAgJ2dsb2JhbCc6IG51bGwsXG4gICAgJ2Vudic6IG51bGwsXG4gICAgJ2FzbTJ3YXNtJzogYXNtMndhc21JbXBvcnRzLFxuICAgICdwYXJlbnQnOiBNb2R1bGUgLy8gTW9kdWxlIGluc2lkZSB3YXNtLWpzLmNwcCByZWZlcnMgdG8gd2FzbS1qcy5jcHA7IHRoaXMgYWxsb3dzIGFjY2VzcyB0byB0aGUgb3V0c2lkZSBwcm9ncmFtLlxuICB9O1xuXG4gIHZhciBleHBvcnRzID0gbnVsbDtcblxuXG4gIGZ1bmN0aW9uIG1lcmdlTWVtb3J5KG5ld0J1ZmZlcikge1xuICAgIC8vIFRoZSB3YXNtIGluc3RhbmNlIGNyZWF0ZXMgaXRzIG1lbW9yeS4gQnV0IHN0YXRpYyBpbml0IGNvZGUgbWlnaHQgaGF2ZSB3cml0dGVuIHRvXG4gICAgLy8gYnVmZmVyIGFscmVhZHksIGluY2x1ZGluZyB0aGUgbWVtIGluaXQgZmlsZSwgYW5kIHdlIG11c3QgY29weSBpdCBvdmVyIGluIGEgcHJvcGVyIG1lcmdlLlxuICAgIC8vIFRPRE86IGF2b2lkIHRoaXMgY29weSwgYnkgYXZvaWRpbmcgc3VjaCBzdGF0aWMgaW5pdCB3cml0ZXNcbiAgICAvLyBUT0RPOiBpbiBzaG9ydGVyIHRlcm0sIGp1c3QgY29weSB1cCB0byB0aGUgbGFzdCBzdGF0aWMgaW5pdCB3cml0ZVxuICAgIHZhciBvbGRCdWZmZXIgPSBNb2R1bGVbJ2J1ZmZlciddO1xuICAgIGlmIChuZXdCdWZmZXIuYnl0ZUxlbmd0aCA8IG9sZEJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICBlcnIoJ3RoZSBuZXcgYnVmZmVyIGluIG1lcmdlTWVtb3J5IGlzIHNtYWxsZXIgdGhhbiB0aGUgcHJldmlvdXMgb25lLiBpbiBuYXRpdmUgd2FzbSwgd2Ugc2hvdWxkIGdyb3cgbWVtb3J5IGhlcmUnKTtcbiAgICB9XG4gICAgdmFyIG9sZFZpZXcgPSBuZXcgSW50OEFycmF5KG9sZEJ1ZmZlcik7XG4gICAgdmFyIG5ld1ZpZXcgPSBuZXcgSW50OEFycmF5KG5ld0J1ZmZlcik7XG5cblxuICAgIG5ld1ZpZXcuc2V0KG9sZFZpZXcpO1xuICAgIHVwZGF0ZUdsb2JhbEJ1ZmZlcihuZXdCdWZmZXIpO1xuICAgIHVwZGF0ZUdsb2JhbEJ1ZmZlclZpZXdzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXhJbXBvcnRzKGltcG9ydHMpIHtcbiAgICByZXR1cm4gaW1wb3J0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJpbmFyeSgpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKE1vZHVsZVsnd2FzbUJpbmFyeSddKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShNb2R1bGVbJ3dhc21CaW5hcnknXSk7XG4gICAgICB9XG4gICAgICBpZiAoTW9kdWxlWydyZWFkQmluYXJ5J10pIHtcbiAgICAgICAgcmV0dXJuIE1vZHVsZVsncmVhZEJpbmFyeSddKHdhc21CaW5hcnlGaWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFwiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgYWJvcnQoZXJyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5hcnlQcm9taXNlKCkge1xuICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgdGhlIGJpbmFyeSB5ZXQsIGFuZCBoYXZlIHRoZSBGZXRjaCBhcGksIHVzZSB0aGF0XG4gICAgLy8gaW4gc29tZSBlbnZpcm9ubWVudHMsIGxpa2UgRWxlY3Ryb24ncyByZW5kZXIgcHJvY2VzcywgRmV0Y2ggYXBpIG1heSBiZSBwcmVzZW50LCBidXQgaGF2ZSBhIGRpZmZlcmVudCBjb250ZXh0IHRoYW4gZXhwZWN0ZWQsIGxldCdzIG9ubHkgdXNlIGl0IG9uIHRoZSBXZWJcbiAgICBpZiAoIU1vZHVsZVsnd2FzbUJpbmFyeSddICYmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSAmJiB0eXBlb2YgZmV0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmZXRjaCh3YXNtQmluYXJ5RmlsZSwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICghcmVzcG9uc2VbJ29rJ10pIHtcbiAgICAgICAgICB0aHJvdyBcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiICsgd2FzbUJpbmFyeUZpbGUgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VbJ2FycmF5QnVmZmVyJ10oKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpbmFyeSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgZ2V0QmluYXJ5IHNob3VsZCBiZSBhYmxlIHRvIGdldCBpdCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVzb2x2ZShnZXRCaW5hcnkoKSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBkby1tZXRob2QgZnVuY3Rpb25zXG5cblxuICBmdW5jdGlvbiBkb05hdGl2ZVdhc20oZ2xvYmFsLCBlbnYsIHByb3ZpZGVkQnVmZmVyKSB7XG4gICAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGVycignbm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBwcmVwYXJlIG1lbW9yeSBpbXBvcnRcbiAgICBpZiAoIShNb2R1bGVbJ3dhc21NZW1vcnknXSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1lbW9yeSkpIHtcbiAgICAgIGVycignbm8gbmF0aXZlIHdhc20gTWVtb3J5IGluIHVzZScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbnZbJ21lbW9yeSddID0gTW9kdWxlWyd3YXNtTWVtb3J5J107XG4gICAgLy8gTG9hZCB0aGUgd2FzbSBtb2R1bGUgYW5kIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB1c2luZyBuYXRpdmUgc3VwcG9ydCBpbiB0aGUgSlMgZW5naW5lLlxuICAgIGluZm9bJ2dsb2JhbCddID0ge1xuICAgICAgJ05hTic6IE5hTixcbiAgICAgICdJbmZpbml0eSc6IEluZmluaXR5XG4gICAgfTtcbiAgICBpbmZvWydnbG9iYWwuTWF0aCddID0gTWF0aDtcbiAgICBpbmZvWydlbnYnXSA9IGVudjtcbiAgICAvLyBoYW5kbGUgYSBnZW5lcmF0ZWQgd2FzbSBpbnN0YW5jZSwgcmVjZWl2aW5nIGl0cyBleHBvcnRzIGFuZFxuICAgIC8vIHBlcmZvcm1pbmcgb3RoZXIgbmVjZXNzYXJ5IHNldHVwXG4gICAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgICAgIGV4cG9ydHMgPSBpbnN0YW5jZS5leHBvcnRzO1xuICAgICAgaWYgKGV4cG9ydHMubWVtb3J5KSBtZXJnZU1lbW9yeShleHBvcnRzLm1lbW9yeSk7XG4gICAgICBNb2R1bGVbJ2FzbSddID0gZXhwb3J0cztcbiAgICAgIE1vZHVsZVtcInVzaW5nV2FzbVwiXSA9IHRydWU7XG4gICAgICByZW1vdmVSdW5EZXBlbmRlbmN5KCd3YXNtLWluc3RhbnRpYXRlJyk7XG4gICAgfVxuICAgIGFkZFJ1bkRlcGVuZGVuY3koJ3dhc20taW5zdGFudGlhdGUnKTtcblxuICAgIC8vIFVzZXIgc2hlbGwgcGFnZXMgY2FuIHdyaXRlIHRoZWlyIG93biBNb2R1bGUuaW5zdGFudGlhdGVXYXNtID0gZnVuY3Rpb24oaW1wb3J0cywgc3VjY2Vzc0NhbGxiYWNrKSBjYWxsYmFja1xuICAgIC8vIHRvIG1hbnVhbGx5IGluc3RhbnRpYXRlIHRoZSBXYXNtIG1vZHVsZSB0aGVtc2VsdmVzLiBUaGlzIGFsbG93cyBwYWdlcyB0byBydW4gdGhlIGluc3RhbnRpYXRpb24gcGFyYWxsZWxcbiAgICAvLyB0byBhbnkgb3RoZXIgYXN5bmMgc3RhcnR1cCBhY3Rpb25zIHRoZXkgYXJlIHBlcmZvcm1pbmcuXG4gICAgaWYgKE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBNb2R1bGVbJ2luc3RhbnRpYXRlV2FzbSddKGluZm8sIHJlY2VpdmVJbnN0YW5jZSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZXJyKCdNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAnICsgZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGVkU291cmNlKG91dHB1dCkge1xuICAgICAgLy8gJ291dHB1dCcgaXMgYSBXZWJBc3NlbWJseUluc3RhbnRpYXRlZFNvdXJjZSBvYmplY3Qgd2hpY2ggaGFzIGJvdGggdGhlIG1vZHVsZSBhbmQgaW5zdGFuY2UuXG4gICAgICAvLyByZWNlaXZlSW5zdGFuY2UoKSB3aWxsIHN3YXAgaW4gdGhlIGV4cG9ydHMgKHRvIE1vZHVsZS5hc20pIHNvIHRoZXkgY2FuIGJlIGNhbGxlZFxuICAgICAgcmVjZWl2ZUluc3RhbmNlKG91dHB1dFsnaW5zdGFuY2UnXSwgb3V0cHV0Wydtb2R1bGUnXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZXIpIHtcbiAgICAgIGdldEJpbmFyeVByb21pc2UoKS50aGVuKGZ1bmN0aW9uKGJpbmFyeSkge1xuICAgICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LCBpbmZvKTtcbiAgICAgIH0pLnRoZW4ocmVjZWl2ZXIsIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBlcnIoJ2ZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICcgKyByZWFzb24pO1xuICAgICAgICBhYm9ydChyZWFzb24pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFByZWZlciBzdHJlYW1pbmcgaW5zdGFudGlhdGlvbiBpZiBhdmFpbGFibGUuXG4gICAgaWYgKCFNb2R1bGVbJ3dhc21CaW5hcnknXSAmJlxuICAgICAgICB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkgJiZcbiAgICAgICAgdHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhmZXRjaCh3YXNtQmluYXJ5RmlsZSwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KSwgaW5mbylcbiAgICAgICAgLnRoZW4ocmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgLy8gV2UgZXhwZWN0IHRoZSBtb3N0IGNvbW1vbiBmYWlsdXJlIGNhdXNlIHRvIGJlIGEgYmFkIE1JTUUgdHlwZSBmb3IgdGhlIGJpbmFyeSxcbiAgICAgICAgICAvLyBpbiB3aGljaCBjYXNlIGZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uIHNob3VsZCB3b3JrLlxuICAgICAgICAgIGVycignd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICcgKyByZWFzb24pO1xuICAgICAgICAgIGVycignZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24nKTtcbiAgICAgICAgICBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0ZWRTb3VyY2UpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGVkU291cmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHt9OyAvLyBubyBleHBvcnRzIHlldDsgd2UnbGwgZmlsbCB0aGVtIGluIGxhdGVyXG4gIH1cblxuXG4gIC8vIFdlIG1heSBoYXZlIGEgcHJlbG9hZGVkIHZhbHVlIGluIE1vZHVsZS5hc20sIHNhdmUgaXRcbiAgTW9kdWxlWydhc21QcmVsb2FkJ10gPSBNb2R1bGVbJ2FzbSddO1xuXG4gIC8vIE1lbW9yeSBncm93dGggaW50ZWdyYXRpb24gY29kZVxuXG4gIHZhciBhc21qc1JlYWxsb2NCdWZmZXIgPSBNb2R1bGVbJ3JlYWxsb2NCdWZmZXInXTtcblxuICB2YXIgd2FzbVJlYWxsb2NCdWZmZXIgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdmFyIFBBR0VfTVVMVElQTEUgPSBNb2R1bGVbXCJ1c2luZ1dhc21cIl0gPyBXQVNNX1BBR0VfU0laRSA6IEFTTUpTX1BBR0VfU0laRTsgLy8gSW4gd2FzbSwgaGVhcCBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NEtCLiBJbiBhc20uanMsIHRoZXkgbmVlZCB0byBiZSBtdWx0aXBsZXMgb2YgMTZNQi5cbiAgICBzaXplID0gYWxpZ25VcChzaXplLCBQQUdFX01VTFRJUExFKTsgLy8gcm91bmQgdXAgdG8gd2FzbSBwYWdlIHNpemVcbiAgICB2YXIgb2xkID0gTW9kdWxlWydidWZmZXInXTtcbiAgICB2YXIgb2xkU2l6ZSA9IG9sZC5ieXRlTGVuZ3RoO1xuICAgIGlmIChNb2R1bGVbXCJ1c2luZ1dhc21cIl0pIHtcbiAgICAgIC8vIG5hdGl2ZSB3YXNtIHN1cHBvcnRcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBNb2R1bGVbJ3dhc21NZW1vcnknXS5ncm93KChzaXplIC0gb2xkU2l6ZSkgLyB3YXNtUGFnZVNpemUpOyAvLyAuZ3JvdygpIHRha2VzIGEgZGVsdGEgY29tcGFyZWQgdG8gdGhlIHByZXZpb3VzIHNpemVcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gKC0xIHwgMCkpIHtcbiAgICAgICAgICAvLyBzdWNjZXNzIGluIG5hdGl2ZSB3YXNtIG1lbW9yeSBncm93dGgsIGdldCB0aGUgYnVmZmVyIGZyb20gdGhlIG1lbW9yeVxuICAgICAgICAgIHJldHVybiBNb2R1bGVbJ2J1ZmZlciddID0gTW9kdWxlWyd3YXNtTWVtb3J5J10uYnVmZmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE1vZHVsZVsncmVhbGxvY0J1ZmZlciddID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIGlmIChmaW5hbE1ldGhvZCA9PT0gJ2FzbWpzJykge1xuICAgICAgcmV0dXJuIGFzbWpzUmVhbGxvY0J1ZmZlcihzaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdhc21SZWFsbG9jQnVmZmVyKHNpemUpO1xuICAgIH1cbiAgfTtcblxuICAvLyB3ZSBtYXkgdHJ5IG1vcmUgdGhhbiBvbmU7IHRoaXMgaXMgdGhlIGZpbmFsIG9uZSwgdGhhdCB3b3JrZWQgYW5kIHdlIGFyZSB1c2luZ1xuICB2YXIgZmluYWxNZXRob2QgPSAnJztcblxuICAvLyBQcm92aWRlIGFuIFwiYXNtLmpzIGZ1bmN0aW9uXCIgZm9yIHRoZSBhcHBsaWNhdGlvbiwgY2FsbGVkIHRvIFwibGlua1wiIHRoZSBhc20uanMgbW9kdWxlLiBXZSBpbnN0YW50aWF0ZVxuICAvLyB0aGUgd2FzbSBtb2R1bGUgYXQgdGhhdCB0aW1lLCBhbmQgaXQgcmVjZWl2ZXMgaW1wb3J0cyBhbmQgcHJvdmlkZXMgZXhwb3J0cyBhbmQgc28gZm9ydGgsIHRoZSBhcHBcbiAgLy8gZG9lc24ndCBuZWVkIHRvIGNhcmUgdGhhdCBpdCBpcyB3YXNtIG9yIG9seWZpbGxlZCB3YXNtIG9yIGFzbS5qcy5cblxuICBNb2R1bGVbJ2FzbSddID0gZnVuY3Rpb24oZ2xvYmFsLCBlbnYsIHByb3ZpZGVkQnVmZmVyKSB7XG4gICAgZW52ID0gZml4SW1wb3J0cyhlbnYpO1xuXG4gICAgLy8gaW1wb3J0IHRhYmxlXG4gICAgaWYgKCFlbnZbJ3RhYmxlJ10pIHtcbiAgICAgIHZhciBUQUJMRV9TSVpFID0gTW9kdWxlWyd3YXNtVGFibGVTaXplJ107XG4gICAgICBpZiAoVEFCTEVfU0laRSA9PT0gdW5kZWZpbmVkKSBUQUJMRV9TSVpFID0gMTAyNDsgLy8gd29ya3MgaW4gYmluYXJ5ZW4gaW50ZXJwcmV0ZXIgYXQgbGVhc3RcbiAgICAgIHZhciBNQVhfVEFCTEVfU0laRSA9IE1vZHVsZVsnd2FzbU1heFRhYmxlU2l6ZSddO1xuICAgICAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIFdlYkFzc2VtYmx5LlRhYmxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChNQVhfVEFCTEVfU0laRSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZW52Wyd0YWJsZSddID0gbmV3IFdlYkFzc2VtYmx5LlRhYmxlKHsgJ2luaXRpYWwnOiBUQUJMRV9TSVpFLCAnbWF4aW11bSc6IE1BWF9UQUJMRV9TSVpFLCAnZWxlbWVudCc6ICdhbnlmdW5jJyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnZbJ3RhYmxlJ10gPSBuZXcgV2ViQXNzZW1ibHkuVGFibGUoeyAnaW5pdGlhbCc6IFRBQkxFX1NJWkUsIGVsZW1lbnQ6ICdhbnlmdW5jJyB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW52Wyd0YWJsZSddID0gbmV3IEFycmF5KFRBQkxFX1NJWkUpOyAvLyB3b3JrcyBpbiBiaW5hcnllbiBpbnRlcnByZXRlciBhdCBsZWFzdFxuICAgICAgfVxuICAgICAgTW9kdWxlWyd3YXNtVGFibGUnXSA9IGVudlsndGFibGUnXTtcbiAgICB9XG5cbiAgICBpZiAoIWVudlsnbWVtb3J5QmFzZSddKSB7XG4gICAgICBlbnZbJ21lbW9yeUJhc2UnXSA9IE1vZHVsZVsnU1RBVElDX0JBU0UnXTsgLy8gdGVsbCB0aGUgbWVtb3J5IHNlZ21lbnRzIHdoZXJlIHRvIHBsYWNlIHRoZW1zZWx2ZXNcbiAgICB9XG4gICAgaWYgKCFlbnZbJ3RhYmxlQmFzZSddKSB7XG4gICAgICBlbnZbJ3RhYmxlQmFzZSddID0gMDsgLy8gdGFibGUgc3RhcnRzIGF0IDAgYnkgZGVmYXVsdCwgaW4gZHluYW1pYyBsaW5raW5nIHRoaXMgd2lsbCBjaGFuZ2VcbiAgICB9XG5cbiAgICAvLyB0cnkgdGhlIG1ldGhvZHMuIGVhY2ggc2hvdWxkIHJldHVybiB0aGUgZXhwb3J0cyBpZiBpdCBzdWNjZWVkZWRcblxuICAgIHZhciBleHBvcnRzO1xuICAgIGV4cG9ydHMgPSBkb05hdGl2ZVdhc20oZ2xvYmFsLCBlbnYsIHByb3ZpZGVkQnVmZmVyKTtcblxuICAgIGFzc2VydChleHBvcnRzLCAnbm8gYmluYXJ5ZW4gbWV0aG9kIHN1Y2NlZWRlZC4nKTtcblxuXG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH07XG5cbiAgdmFyIG1ldGhvZEhhbmRsZXIgPSBNb2R1bGVbJ2FzbSddOyAvLyBub3RlIG91ciBtZXRob2QgaGFuZGxlciwgYXMgd2UgbWF5IG1vZGlmeSBNb2R1bGVbJ2FzbSddIGxhdGVyXG59XG5cbmludGVncmF0ZVdhc21KUygpO1xuXG4vLyA9PT0gQm9keSA9PT1cblxudmFyIEFTTV9DT05TVFMgPSBbXTtcblxuXG5cblxuXG5TVEFUSUNfQkFTRSA9IEdMT0JBTF9CQVNFO1xuXG5TVEFUSUNUT1AgPSBTVEFUSUNfQkFTRSArIDUyMDY0O1xuLyogZ2xvYmFsIGluaXRpYWxpemVycyAqLyAgX19BVElOSVRfXy5wdXNoKCk7XG5cblxuXG5cblxuXG5cbnZhciBTVEFUSUNfQlVNUCA9IDUyMDY0O1xuTW9kdWxlW1wiU1RBVElDX0JBU0VcIl0gPSBTVEFUSUNfQkFTRTtcbk1vZHVsZVtcIlNUQVRJQ19CVU1QXCJdID0gU1RBVElDX0JVTVA7XG5cbi8qIG5vIG1lbW9yeSBpbml0aWFsaXplciAqL1xudmFyIHRlbXBEb3VibGVQdHIgPSBTVEFUSUNUT1A7IFNUQVRJQ1RPUCArPSAxNjtcblxuZnVuY3Rpb24gY29weVRlbXBGbG9hdChwdHIpIHsgLy8gZnVuY3Rpb25zLCBiZWNhdXNlIGlubGluaW5nIHRoaXMgY29kZSBpbmNyZWFzZXMgY29kZSBzaXplIHRvbyBtdWNoXG5cbiAgSEVBUDhbdGVtcERvdWJsZVB0cl0gPSBIRUFQOFtwdHJdO1xuXG4gIEhFQVA4W3RlbXBEb3VibGVQdHIrMV0gPSBIRUFQOFtwdHIrMV07XG5cbiAgSEVBUDhbdGVtcERvdWJsZVB0cisyXSA9IEhFQVA4W3B0cisyXTtcblxuICBIRUFQOFt0ZW1wRG91YmxlUHRyKzNdID0gSEVBUDhbcHRyKzNdO1xuXG59XG5cbmZ1bmN0aW9uIGNvcHlUZW1wRG91YmxlKHB0cikge1xuXG4gIEhFQVA4W3RlbXBEb3VibGVQdHJdID0gSEVBUDhbcHRyXTtcblxuICBIRUFQOFt0ZW1wRG91YmxlUHRyKzFdID0gSEVBUDhbcHRyKzFdO1xuXG4gIEhFQVA4W3RlbXBEb3VibGVQdHIrMl0gPSBIRUFQOFtwdHIrMl07XG5cbiAgSEVBUDhbdGVtcERvdWJsZVB0ciszXSA9IEhFQVA4W3B0ciszXTtcblxuICBIRUFQOFt0ZW1wRG91YmxlUHRyKzRdID0gSEVBUDhbcHRyKzRdO1xuXG4gIEhFQVA4W3RlbXBEb3VibGVQdHIrNV0gPSBIRUFQOFtwdHIrNV07XG5cbiAgSEVBUDhbdGVtcERvdWJsZVB0cis2XSA9IEhFQVA4W3B0cis2XTtcblxuICBIRUFQOFt0ZW1wRG91YmxlUHRyKzddID0gSEVBUDhbcHRyKzddO1xuXG59XG5cbi8vIHt7UFJFX0xJQlJBUll9fVxuXG5cbiAgXG4gIHZhciBTWVNDQUxMUz17dmFyYXJnczowLGdldDpmdW5jdGlvbiAodmFyYXJncykge1xuICAgICAgICBTWVNDQUxMUy52YXJhcmdzICs9IDQ7XG4gICAgICAgIHZhciByZXQgPSBIRUFQMzJbKCgoU1lTQ0FMTFMudmFyYXJncyktKDQpKT4+MildO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxnZXRTdHI6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmV0ID0gUG9pbnRlcl9zdHJpbmdpZnkoU1lTQ0FMTFMuZ2V0KCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxnZXQ2NDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb3cgPSBTWVNDQUxMUy5nZXQoKSwgaGlnaCA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICBpZiAobG93ID49IDApIGFzc2VydChoaWdoID09PSAwKTtcbiAgICAgICAgZWxzZSBhc3NlcnQoaGlnaCA9PT0gLTEpO1xuICAgICAgICByZXR1cm4gbG93O1xuICAgICAgfSxnZXRaZXJvOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXNzZXJ0KFNZU0NBTExTLmdldCgpID09PSAwKTtcbiAgICAgIH19O2Z1bmN0aW9uIF9fX3N5c2NhbGwxNDAod2hpY2gsIHZhcmFyZ3MpIHtTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcbiAgdHJ5IHtcbiAgIC8vIGxsc2Vla1xuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRCgpLCBvZmZzZXRfaGlnaCA9IFNZU0NBTExTLmdldCgpLCBvZmZzZXRfbG93ID0gU1lTQ0FMTFMuZ2V0KCksIHJlc3VsdCA9IFNZU0NBTExTLmdldCgpLCB3aGVuY2UgPSBTWVNDQUxMUy5nZXQoKTtcbiAgICAgIC8vIE5PVEU6IG9mZnNldF9oaWdoIGlzIHVudXNlZCAtIEVtc2NyaXB0ZW4ncyBvZmZfdCBpcyAzMi1iaXRcbiAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXRfbG93O1xuICAgICAgRlMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpO1xuICAgICAgSEVBUDMyWygocmVzdWx0KT4+MildPXN0cmVhbS5wb3NpdGlvbjtcbiAgICAgIGlmIChzdHJlYW0uZ2V0ZGVudHMgJiYgb2Zmc2V0ID09PSAwICYmIHdoZW5jZSA9PT0gMCkgc3RyZWFtLmdldGRlbnRzID0gbnVsbDsgLy8gcmVzZXQgcmVhZGRpciBzdGF0ZVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIFxuICBmdW5jdGlvbiBmbHVzaF9OT19GSUxFU1lTVEVNKCkge1xuICAgICAgLy8gZmx1c2ggYW55dGhpbmcgcmVtYWluaW5nIGluIHRoZSBidWZmZXJzIGR1cmluZyBzaHV0ZG93blxuICAgICAgdmFyIGZmbHVzaCA9IE1vZHVsZVtcIl9mZmx1c2hcIl07XG4gICAgICBpZiAoZmZsdXNoKSBmZmx1c2goMCk7XG4gICAgICB2YXIgcHJpbnRDaGFyID0gX19fc3lzY2FsbDE0Ni5wcmludENoYXI7XG4gICAgICBpZiAoIXByaW50Q2hhcikgcmV0dXJuO1xuICAgICAgdmFyIGJ1ZmZlcnMgPSBfX19zeXNjYWxsMTQ2LmJ1ZmZlcnM7XG4gICAgICBpZiAoYnVmZmVyc1sxXS5sZW5ndGgpIHByaW50Q2hhcigxLCAxMCk7XG4gICAgICBpZiAoYnVmZmVyc1syXS5sZW5ndGgpIHByaW50Q2hhcigyLCAxMCk7XG4gICAgfWZ1bmN0aW9uIF9fX3N5c2NhbGwxNDYod2hpY2gsIHZhcmFyZ3MpIHtTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcbiAgdHJ5IHtcbiAgIC8vIHdyaXRldlxuICAgICAgLy8gaGFjayB0byBzdXBwb3J0IHByaW50ZiBpbiBGSUxFU1lTVEVNPTBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXQoKSwgaW92ID0gU1lTQ0FMTFMuZ2V0KCksIGlvdmNudCA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgdmFyIHJldCA9IDA7XG4gICAgICBpZiAoIV9fX3N5c2NhbGwxNDYuYnVmZmVycykge1xuICAgICAgICBfX19zeXNjYWxsMTQ2LmJ1ZmZlcnMgPSBbbnVsbCwgW10sIFtdXTsgLy8gMSA9PiBzdGRvdXQsIDIgPT4gc3RkZXJyXG4gICAgICAgIF9fX3N5c2NhbGwxNDYucHJpbnRDaGFyID0gZnVuY3Rpb24oc3RyZWFtLCBjdXJyKSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IF9fX3N5c2NhbGwxNDYuYnVmZmVyc1tzdHJlYW1dO1xuICAgICAgICAgIGFzc2VydChidWZmZXIpO1xuICAgICAgICAgIGlmIChjdXJyID09PSAwIHx8IGN1cnIgPT09IDEwKSB7XG4gICAgICAgICAgICAoc3RyZWFtID09PSAxID8gb3V0IDogZXJyKShVVEY4QXJyYXlUb1N0cmluZyhidWZmZXIsIDApKTtcbiAgICAgICAgICAgIGJ1ZmZlci5sZW5ndGggPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIucHVzaChjdXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7XG4gICAgICAgIHZhciBwdHIgPSBIRUFQMzJbKCgoaW92KSsoaSo4KSk+PjIpXTtcbiAgICAgICAgdmFyIGxlbiA9IEhFQVAzMlsoKChpb3YpKyhpKjggKyA0KSk+PjIpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIF9fX3N5c2NhbGwxNDYucHJpbnRDaGFyKHN0cmVhbSwgSEVBUFU4W3B0citqXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ICs9IGxlbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGw2KHdoaWNoLCB2YXJhcmdzKSB7U1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XG4gIHRyeSB7XG4gICAvLyBjbG9zZVxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRCgpO1xuICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgYWJvcnQoZSk7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfYWJvcnQoKSB7XG4gICAgICBNb2R1bGVbJ2Fib3J0J10oKTtcbiAgICB9XG5cbiAgIFxuXG4gIHZhciBfbGx2bV9jb3NfZjY0PU1hdGhfY29zO1xuXG4gIHZhciBfbGx2bV9jdGx6X2kzMj10cnVlO1xuXG4gIFxuICBmdW5jdGlvbiBfbGx2bV9leHAyX2YzMih4KSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgeCk7XG4gICAgfWZ1bmN0aW9uIF9sbHZtX2V4cDJfZjY0KCkge1xuICByZXR1cm4gX2xsdm1fZXhwMl9mMzIuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICB9XG5cbiAgdmFyIF9sbHZtX2V4cF9mNjQ9TWF0aF9leHA7XG5cbiAgdmFyIF9sbHZtX2ZhYnNfZjMyPU1hdGhfYWJzO1xuXG4gIHZhciBfbGx2bV9mbG9vcl9mMzI9TWF0aF9mbG9vcjtcblxuICB2YXIgX2xsdm1fZmxvb3JfZjY0PU1hdGhfZmxvb3I7XG5cbiAgXG4gIGZ1bmN0aW9uIF9sbHZtX2xvZzEwX2YzMih4KSB7XG4gICAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7IC8vIFRPRE86IE1hdGgubG9nMTAsIHdoZW4gYnJvd3NlciBzdXBwb3J0IGlzIHRoZXJlXG4gICAgfWZ1bmN0aW9uIF9sbHZtX2xvZzEwX2Y2NCgpIHtcbiAgcmV0dXJuIF9sbHZtX2xvZzEwX2YzMi5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gIH1cblxuICB2YXIgX2xsdm1fbG9nX2Y2ND1NYXRoX2xvZztcblxuICB2YXIgX2xsdm1fc2luX2Y2ND1NYXRoX3NpbjtcblxuICB2YXIgX2xsdm1fc3FydF9mMzI9TWF0aF9zcXJ0O1xuXG4gIHZhciBfbGx2bV9zcXJ0X2Y2ND1NYXRoX3NxcnQ7XG5cbiAgZnVuY3Rpb24gX2xsdm1fc3RhY2tyZXN0b3JlKHApIHtcbiAgICAgIHZhciBzZWxmID0gX2xsdm1fc3RhY2tzYXZlO1xuICAgICAgdmFyIHJldCA9IHNlbGYuTExWTV9TQVZFRFNUQUNLU1twXTtcbiAgICAgIHNlbGYuTExWTV9TQVZFRFNUQUNLUy5zcGxpY2UocCwgMSk7XG4gICAgICBzdGFja1Jlc3RvcmUocmV0KTtcbiAgICB9XG5cbiAgZnVuY3Rpb24gX2xsdm1fc3RhY2tzYXZlKCkge1xuICAgICAgdmFyIHNlbGYgPSBfbGx2bV9zdGFja3NhdmU7XG4gICAgICBpZiAoIXNlbGYuTExWTV9TQVZFRFNUQUNLUykge1xuICAgICAgICBzZWxmLkxMVk1fU0FWRURTVEFDS1MgPSBbXTtcbiAgICAgIH1cbiAgICAgIHNlbGYuTExWTV9TQVZFRFNUQUNLUy5wdXNoKHN0YWNrU2F2ZSgpKTtcbiAgICAgIHJldHVybiBzZWxmLkxMVk1fU0FWRURTVEFDS1MubGVuZ3RoLTE7XG4gICAgfVxuXG4gIFxuICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnKGRlc3QsIHNyYywgbnVtKSB7XG4gICAgICBIRUFQVTguc2V0KEhFQVBVOC5zdWJhcnJheShzcmMsIHNyYytudW0pLCBkZXN0KTtcbiAgICAgIHJldHVybiBkZXN0O1xuICAgIH0gXG5cbiAgIFxuXG4gICBcblxuICBcbiAgICBcblxuICBcbiAgZnVuY3Rpb24gX19fc2V0RXJyTm8odmFsdWUpIHtcbiAgICAgIGlmIChNb2R1bGVbJ19fX2Vycm5vX2xvY2F0aW9uJ10pIEhFQVAzMlsoKE1vZHVsZVsnX19fZXJybm9fbG9jYXRpb24nXSgpKT4+MildPXZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gXG5EWU5BTUlDVE9QX1BUUiA9IHN0YXRpY0FsbG9jKDQpO1xuXG5TVEFDS19CQVNFID0gU1RBQ0tUT1AgPSBhbGlnbk1lbW9yeShTVEFUSUNUT1ApO1xuXG5TVEFDS19NQVggPSBTVEFDS19CQVNFICsgVE9UQUxfU1RBQ0s7XG5cbkRZTkFNSUNfQkFTRSA9IGFsaWduTWVtb3J5KFNUQUNLX01BWCk7XG5cbkhFQVAzMltEWU5BTUlDVE9QX1BUUj4+Ml0gPSBEWU5BTUlDX0JBU0U7XG5cbnN0YXRpY1NlYWxlZCA9IHRydWU7IC8vIHNlYWwgdGhlIHN0YXRpYyBwb3J0aW9uIG9mIG1lbW9yeVxuXG52YXIgQVNTRVJUSU9OUyA9IGZhbHNlO1xuXG4vLyBDb3B5cmlnaHQgMjAxNyBUaGUgRW1zY3JpcHRlbiBBdXRob3JzLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIEVtc2NyaXB0ZW4gaXMgYXZhaWxhYmxlIHVuZGVyIHR3byBzZXBhcmF0ZSBsaWNlbnNlcywgdGhlIE1JVCBsaWNlbnNlIGFuZCB0aGVcbi8vIFVuaXZlcnNpdHkgb2YgSWxsaW5vaXMvTkNTQSBPcGVuIFNvdXJjZSBMaWNlbnNlLiAgQm90aCB0aGVzZSBsaWNlbnNlcyBjYW4gYmVcbi8vIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oc3RyaW5nLCBib29sZWFuPSwgbnVtYmVyPSl9ICovXG5mdW5jdGlvbiBpbnRBcnJheUZyb21TdHJpbmcoc3RyaW5neSwgZG9udEFkZE51bGwsIGxlbmd0aCkge1xuICB2YXIgbGVuID0gbGVuZ3RoID4gMCA/IGxlbmd0aCA6IGxlbmd0aEJ5dGVzVVRGOChzdHJpbmd5KSsxO1xuICB2YXIgdThhcnJheSA9IG5ldyBBcnJheShsZW4pO1xuICB2YXIgbnVtQnl0ZXNXcml0dGVuID0gc3RyaW5nVG9VVEY4QXJyYXkoc3RyaW5neSwgdThhcnJheSwgMCwgdThhcnJheS5sZW5ndGgpO1xuICBpZiAoZG9udEFkZE51bGwpIHU4YXJyYXkubGVuZ3RoID0gbnVtQnl0ZXNXcml0dGVuO1xuICByZXR1cm4gdThhcnJheTtcbn1cblxuZnVuY3Rpb24gaW50QXJyYXlUb1N0cmluZyhhcnJheSkge1xuICB2YXIgcmV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hyID0gYXJyYXlbaV07XG4gICAgaWYgKGNociA+IDB4RkYpIHtcbiAgICAgIGlmIChBU1NFUlRJT05TKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgJ0NoYXJhY3RlciBjb2RlICcgKyBjaHIgKyAnICgnICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpICsgJykgIGF0IG9mZnNldCAnICsgaSArICcgbm90IGluIDB4MDAtMHhGRi4nKTtcbiAgICAgIH1cbiAgICAgIGNociAmPSAweEZGO1xuICAgIH1cbiAgICByZXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikpO1xuICB9XG4gIHJldHVybiByZXQuam9pbignJyk7XG59XG5cblxuXG5Nb2R1bGVbJ3dhc21UYWJsZVNpemUnXSA9IDE2O1xuXG5Nb2R1bGVbJ3dhc21NYXhUYWJsZVNpemUnXSA9IDE2O1xuXG5mdW5jdGlvbiBpbnZva2VfaWkoaW5kZXgsYTEpIHtcbiAgdmFyIHNwID0gc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIE1vZHVsZVtcImR5bkNhbGxfaWlcIl0oaW5kZXgsYTEpO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzdGFja1Jlc3RvcmUoc3ApO1xuICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlO1xuICAgIE1vZHVsZVtcInNldFRocmV3XCJdKDEsIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZV9paWlpKGluZGV4LGExLGEyLGEzKSB7XG4gIHZhciBzcCA9IHN0YWNrU2F2ZSgpO1xuICB0cnkge1xuICAgIHJldHVybiBNb2R1bGVbXCJkeW5DYWxsX2lpaWlcIl0oaW5kZXgsYTEsYTIsYTMpO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzdGFja1Jlc3RvcmUoc3ApO1xuICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlO1xuICAgIE1vZHVsZVtcInNldFRocmV3XCJdKDEsIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZV9paWlpaWlpKGluZGV4LGExLGEyLGEzLGE0LGE1LGE2KSB7XG4gIHZhciBzcCA9IHN0YWNrU2F2ZSgpO1xuICB0cnkge1xuICAgIHJldHVybiBNb2R1bGVbXCJkeW5DYWxsX2lpaWlpaWlcIl0oaW5kZXgsYTEsYTIsYTMsYTQsYTUsYTYpO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzdGFja1Jlc3RvcmUoc3ApO1xuICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlO1xuICAgIE1vZHVsZVtcInNldFRocmV3XCJdKDEsIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZV92aWlpaWlpaShpbmRleCxhMSxhMixhMyxhNCxhNSxhNixhNykge1xuICB2YXIgc3AgPSBzdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlpaWlpXCJdKGluZGV4LGExLGEyLGEzLGE0LGE1LGE2LGE3KTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc3RhY2tSZXN0b3JlKHNwKTtcbiAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZTtcbiAgICBNb2R1bGVbXCJzZXRUaHJld1wiXSgxLCAwKTtcbiAgfVxufVxuXG5Nb2R1bGUuYXNtR2xvYmFsQXJnID0ge307XG5cbk1vZHVsZS5hc21MaWJyYXJ5QXJnID0geyBcImFib3J0XCI6IGFib3J0LCBcImFzc2VydFwiOiBhc3NlcnQsIFwiZW5sYXJnZU1lbW9yeVwiOiBlbmxhcmdlTWVtb3J5LCBcImdldFRvdGFsTWVtb3J5XCI6IGdldFRvdGFsTWVtb3J5LCBcImFib3J0T25DYW5ub3RHcm93TWVtb3J5XCI6IGFib3J0T25DYW5ub3RHcm93TWVtb3J5LCBcImludm9rZV9paVwiOiBpbnZva2VfaWksIFwiaW52b2tlX2lpaWlcIjogaW52b2tlX2lpaWksIFwiaW52b2tlX2lpaWlpaWlcIjogaW52b2tlX2lpaWlpaWksIFwiaW52b2tlX3ZpaWlpaWlpXCI6IGludm9rZV92aWlpaWlpaSwgXCJfX19zZXRFcnJOb1wiOiBfX19zZXRFcnJObywgXCJfX19zeXNjYWxsMTQwXCI6IF9fX3N5c2NhbGwxNDAsIFwiX19fc3lzY2FsbDE0NlwiOiBfX19zeXNjYWxsMTQ2LCBcIl9fX3N5c2NhbGw2XCI6IF9fX3N5c2NhbGw2LCBcIl9hYm9ydFwiOiBfYWJvcnQsIFwiX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZ1wiOiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnLCBcIl9sbHZtX2Nvc19mNjRcIjogX2xsdm1fY29zX2Y2NCwgXCJfbGx2bV9leHAyX2YzMlwiOiBfbGx2bV9leHAyX2YzMiwgXCJfbGx2bV9leHAyX2Y2NFwiOiBfbGx2bV9leHAyX2Y2NCwgXCJfbGx2bV9leHBfZjY0XCI6IF9sbHZtX2V4cF9mNjQsIFwiX2xsdm1fZmFic19mMzJcIjogX2xsdm1fZmFic19mMzIsIFwiX2xsdm1fZmxvb3JfZjMyXCI6IF9sbHZtX2Zsb29yX2YzMiwgXCJfbGx2bV9mbG9vcl9mNjRcIjogX2xsdm1fZmxvb3JfZjY0LCBcIl9sbHZtX2xvZzEwX2YzMlwiOiBfbGx2bV9sb2cxMF9mMzIsIFwiX2xsdm1fbG9nMTBfZjY0XCI6IF9sbHZtX2xvZzEwX2Y2NCwgXCJfbGx2bV9sb2dfZjY0XCI6IF9sbHZtX2xvZ19mNjQsIFwiX2xsdm1fc2luX2Y2NFwiOiBfbGx2bV9zaW5fZjY0LCBcIl9sbHZtX3NxcnRfZjMyXCI6IF9sbHZtX3NxcnRfZjMyLCBcIl9sbHZtX3NxcnRfZjY0XCI6IF9sbHZtX3NxcnRfZjY0LCBcIl9sbHZtX3N0YWNrcmVzdG9yZVwiOiBfbGx2bV9zdGFja3Jlc3RvcmUsIFwiX2xsdm1fc3RhY2tzYXZlXCI6IF9sbHZtX3N0YWNrc2F2ZSwgXCJmbHVzaF9OT19GSUxFU1lTVEVNXCI6IGZsdXNoX05PX0ZJTEVTWVNURU0sIFwiRFlOQU1JQ1RPUF9QVFJcIjogRFlOQU1JQ1RPUF9QVFIsIFwidGVtcERvdWJsZVB0clwiOiB0ZW1wRG91YmxlUHRyLCBcIlNUQUNLVE9QXCI6IFNUQUNLVE9QLCBcIlNUQUNLX01BWFwiOiBTVEFDS19NQVggfTtcbi8vIEVNU0NSSVBURU5fU1RBUlRfQVNNXG52YXIgYXNtID1Nb2R1bGVbXCJhc21cIl0vLyBFTVNDUklQVEVOX0VORF9BU01cbihNb2R1bGUuYXNtR2xvYmFsQXJnLCBNb2R1bGUuYXNtTGlicmFyeUFyZywgYnVmZmVyKTtcblxuTW9kdWxlW1wiYXNtXCJdID0gYXNtO1xudmFyIF9mcmVlID0gTW9kdWxlW1wiX2ZyZWVcIl0gPSBmdW5jdGlvbigpIHsgIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfZnJlZVwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XG52YXIgX2xsdm1fYnN3YXBfaTMyID0gTW9kdWxlW1wiX2xsdm1fYnN3YXBfaTMyXCJdID0gZnVuY3Rpb24oKSB7ICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX2xsdm1fYnN3YXBfaTMyXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcbnZhciBfbWFsbG9jID0gTW9kdWxlW1wiX21hbGxvY1wiXSA9IGZ1bmN0aW9uKCkgeyAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9tYWxsb2NcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xudmFyIF9tZW1jcHkgPSBNb2R1bGVbXCJfbWVtY3B5XCJdID0gZnVuY3Rpb24oKSB7ICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX21lbWNweVwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XG52YXIgX21lbW1vdmUgPSBNb2R1bGVbXCJfbWVtbW92ZVwiXSA9IGZ1bmN0aW9uKCkgeyAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9tZW1tb3ZlXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcbnZhciBfbWVtc2V0ID0gTW9kdWxlW1wiX21lbXNldFwiXSA9IGZ1bmN0aW9uKCkgeyAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9tZW1zZXRcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xudmFyIF9vcHVzX2RlY29kZV9mbG9hdCA9IE1vZHVsZVtcIl9vcHVzX2RlY29kZV9mbG9hdFwiXSA9IGZ1bmN0aW9uKCkgeyAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9vcHVzX2RlY29kZV9mbG9hdFwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XG52YXIgX29wdXNfZGVjb2Rlcl9jcmVhdGUgPSBNb2R1bGVbXCJfb3B1c19kZWNvZGVyX2NyZWF0ZVwiXSA9IGZ1bmN0aW9uKCkgeyAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9vcHVzX2RlY29kZXJfY3JlYXRlXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcbnZhciBfb3B1c19kZWNvZGVyX2Rlc3Ryb3kgPSBNb2R1bGVbXCJfb3B1c19kZWNvZGVyX2Rlc3Ryb3lcIl0gPSBmdW5jdGlvbigpIHsgIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfb3B1c19kZWNvZGVyX2Rlc3Ryb3lcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xudmFyIF9vcHVzX2VuY29kZV9mbG9hdCA9IE1vZHVsZVtcIl9vcHVzX2VuY29kZV9mbG9hdFwiXSA9IGZ1bmN0aW9uKCkgeyAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9vcHVzX2VuY29kZV9mbG9hdFwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XG52YXIgX29wdXNfZW5jb2Rlcl9jcmVhdGUgPSBNb2R1bGVbXCJfb3B1c19lbmNvZGVyX2NyZWF0ZVwiXSA9IGZ1bmN0aW9uKCkgeyAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9vcHVzX2VuY29kZXJfY3JlYXRlXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcbnZhciBfb3B1c19lbmNvZGVyX2N0bCA9IE1vZHVsZVtcIl9vcHVzX2VuY29kZXJfY3RsXCJdID0gZnVuY3Rpb24oKSB7ICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX29wdXNfZW5jb2Rlcl9jdGxcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xudmFyIF9yaW50ZiA9IE1vZHVsZVtcIl9yaW50ZlwiXSA9IGZ1bmN0aW9uKCkgeyAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9yaW50ZlwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XG52YXIgX3NicmsgPSBNb2R1bGVbXCJfc2Jya1wiXSA9IGZ1bmN0aW9uKCkgeyAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9zYnJrXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcbnZhciBfc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3kgPSBNb2R1bGVbXCJfc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3lcIl0gPSBmdW5jdGlvbigpIHsgIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3lcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xudmFyIF9zcGVleF9yZXNhbXBsZXJfaW5pdCA9IE1vZHVsZVtcIl9zcGVleF9yZXNhbXBsZXJfaW5pdFwiXSA9IGZ1bmN0aW9uKCkgeyAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9zcGVleF9yZXNhbXBsZXJfaW5pdFwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XG52YXIgX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0ID0gTW9kdWxlW1wiX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0XCJdID0gZnVuY3Rpb24oKSB7ICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0XCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcbnZhciBlc3RhYmxpc2hTdGFja1NwYWNlID0gTW9kdWxlW1wiZXN0YWJsaXNoU3RhY2tTcGFjZVwiXSA9IGZ1bmN0aW9uKCkgeyAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcImVzdGFibGlzaFN0YWNrU3BhY2VcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xudmFyIGdldFRlbXBSZXQwID0gTW9kdWxlW1wiZ2V0VGVtcFJldDBcIl0gPSBmdW5jdGlvbigpIHsgIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJnZXRUZW1wUmV0MFwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XG52YXIgcnVuUG9zdFNldHMgPSBNb2R1bGVbXCJydW5Qb3N0U2V0c1wiXSA9IGZ1bmN0aW9uKCkgeyAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcInJ1blBvc3RTZXRzXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcbnZhciBzZXRUZW1wUmV0MCA9IE1vZHVsZVtcInNldFRlbXBSZXQwXCJdID0gZnVuY3Rpb24oKSB7ICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wic2V0VGVtcFJldDBcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xudmFyIHNldFRocmV3ID0gTW9kdWxlW1wic2V0VGhyZXdcIl0gPSBmdW5jdGlvbigpIHsgIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJzZXRUaHJld1wiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XG52YXIgc3RhY2tBbGxvYyA9IE1vZHVsZVtcInN0YWNrQWxsb2NcIl0gPSBmdW5jdGlvbigpIHsgIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJzdGFja0FsbG9jXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcbnZhciBzdGFja1Jlc3RvcmUgPSBNb2R1bGVbXCJzdGFja1Jlc3RvcmVcIl0gPSBmdW5jdGlvbigpIHsgIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJzdGFja1Jlc3RvcmVcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xudmFyIHN0YWNrU2F2ZSA9IE1vZHVsZVtcInN0YWNrU2F2ZVwiXSA9IGZ1bmN0aW9uKCkgeyAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcInN0YWNrU2F2ZVwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XG52YXIgZHluQ2FsbF9paSA9IE1vZHVsZVtcImR5bkNhbGxfaWlcIl0gPSBmdW5jdGlvbigpIHsgIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJkeW5DYWxsX2lpXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcbnZhciBkeW5DYWxsX2lpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2lpaWlcIl0gPSBmdW5jdGlvbigpIHsgIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJkeW5DYWxsX2lpaWlcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xudmFyIGR5bkNhbGxfaWlpaWlpaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlpaWlpaVwiXSA9IGZ1bmN0aW9uKCkgeyAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcImR5bkNhbGxfaWlpaWlpaVwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XG52YXIgZHluQ2FsbF92aWlpaWlpaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWlpaWlcIl0gPSBmdW5jdGlvbigpIHsgIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJkeW5DYWxsX3ZpaWlpaWlpXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcbjtcblxuXG5cbi8vID09PSBBdXRvLWdlbmVyYXRlZCBwb3N0YW1ibGUgc2V0dXAgZW50cnkgc3R1ZmYgPT09XG5cbk1vZHVsZVsnYXNtJ10gPSBhc207XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vLyBNb2R1bGFyaXplIG1vZGUgcmV0dXJucyBhIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgY2FsbGVkIHRvXG4vLyBjcmVhdGUgaW5zdGFuY2VzLiBUaGUgaW5zdGFuY2VzIHByb3ZpZGUgYSB0aGVuKCkgbWV0aG9kLFxuLy8gbXVzdCBsaWtlIGEgUHJvbWlzZSwgdGhhdCByZWNlaXZlcyBhIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2tcbi8vIGlzIGNhbGxlZCB3aGVuIHRoZSBtb2R1bGUgaXMgcmVhZHkgdG8gcnVuLCB3aXRoIHRoZSBtb2R1bGVcbi8vIGFzIGEgcGFyYW1ldGVyLiAoTGlrZSBhIFByb21pc2UsIGl0IGFsc28gcmV0dXJucyB0aGUgbW9kdWxlXG4vLyBzbyB5b3UgY2FuIHVzZSB0aGUgb3V0cHV0IG9mIC50aGVuKC4uKSkuXG5Nb2R1bGVbJ3RoZW4nXSA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgLy8gV2UgbWF5IGFscmVhZHkgYmUgcmVhZHkgdG8gcnVuIGNvZGUgYXQgdGhpcyB0aW1lLiBpZlxuICAvLyBzbywganVzdCBxdWV1ZSBhIGNhbGwgdG8gdGhlIGNhbGxiYWNrLlxuICBpZiAoTW9kdWxlWydjYWxsZWRSdW4nXSkge1xuICAgIGZ1bmMoTW9kdWxlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB3ZSBhcmUgbm90IHJlYWR5IHRvIGNhbGwgdGhlbigpIHlldC4gd2UgbXVzdCBjYWxsIGl0XG4gICAgLy8gYXQgdGhlIHNhbWUgdGltZSB3ZSB3b3VsZCBjYWxsIG9uUnVudGltZUluaXRpYWxpemVkLlxuICAgIHZhciBvbGQgPSBNb2R1bGVbJ29uUnVudGltZUluaXRpYWxpemVkJ107XG4gICAgTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAob2xkKSBvbGQoKTtcbiAgICAgIGZ1bmMoTW9kdWxlKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBNb2R1bGU7XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Vycm9yfVxuICogQHRoaXMge0V4aXRTdGF0dXN9XG4gKi9cbmZ1bmN0aW9uIEV4aXRTdGF0dXMoc3RhdHVzKSB7XG4gIHRoaXMubmFtZSA9IFwiRXhpdFN0YXR1c1wiO1xuICB0aGlzLm1lc3NhZ2UgPSBcIlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoXCIgKyBzdGF0dXMgKyBcIilcIjtcbiAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG59O1xuRXhpdFN0YXR1cy5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbkV4aXRTdGF0dXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXhpdFN0YXR1cztcblxudmFyIGluaXRpYWxTdGFja1RvcDtcbnZhciBjYWxsZWRNYWluID0gZmFsc2U7XG5cbmRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uIHJ1bkNhbGxlcigpIHtcbiAgLy8gSWYgcnVuIGhhcyBuZXZlciBiZWVuIGNhbGxlZCwgYW5kIHdlIHNob3VsZCBjYWxsIHJ1biAoSU5WT0tFX1JVTiBpcyB0cnVlLCBhbmQgTW9kdWxlLm5vSW5pdGlhbFJ1biBpcyBub3QgZmFsc2UpXG4gIGlmICghTW9kdWxlWydjYWxsZWRSdW4nXSkgcnVuKCk7XG4gIGlmICghTW9kdWxlWydjYWxsZWRSdW4nXSkgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gcnVuQ2FsbGVyOyAvLyB0cnkgdGhpcyBhZ2FpbiBsYXRlciwgYWZ0ZXIgbmV3IGRlcHMgYXJlIGZ1bGZpbGxlZFxufVxuXG5cblxuXG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oQXJyYXk9KX0gKi9cbmZ1bmN0aW9uIHJ1bihhcmdzKSB7XG4gIGFyZ3MgPSBhcmdzIHx8IE1vZHVsZVsnYXJndW1lbnRzJ107XG5cbiAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuXG4gIHByZVJ1bigpO1xuXG4gIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSByZXR1cm47IC8vIGEgcHJlUnVuIGFkZGVkIGEgZGVwZW5kZW5jeSwgcnVuIHdpbGwgYmUgY2FsbGVkIGxhdGVyXG4gIGlmIChNb2R1bGVbJ2NhbGxlZFJ1biddKSByZXR1cm47IC8vIHJ1biBtYXkgaGF2ZSBqdXN0IGJlZW4gY2FsbGVkIHRocm91Z2ggZGVwZW5kZW5jaWVzIGJlaW5nIGZ1bGZpbGxlZCBqdXN0IGluIHRoaXMgdmVyeSBmcmFtZVxuXG4gIGZ1bmN0aW9uIGRvUnVuKCkge1xuICAgIGlmIChNb2R1bGVbJ2NhbGxlZFJ1biddKSByZXR1cm47IC8vIHJ1biBtYXkgaGF2ZSBqdXN0IGJlZW4gY2FsbGVkIHdoaWxlIHRoZSBhc3luYyBzZXRTdGF0dXMgdGltZSBiZWxvdyB3YXMgaGFwcGVuaW5nXG4gICAgTW9kdWxlWydjYWxsZWRSdW4nXSA9IHRydWU7XG5cbiAgICBpZiAoQUJPUlQpIHJldHVybjtcblxuICAgIGVuc3VyZUluaXRSdW50aW1lKCk7XG5cbiAgICBwcmVNYWluKCk7XG5cbiAgICBpZiAoTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddKSBNb2R1bGVbJ29uUnVudGltZUluaXRpYWxpemVkJ10oKTtcblxuXG4gICAgcG9zdFJ1bigpO1xuICB9XG5cbiAgaWYgKE1vZHVsZVsnc2V0U3RhdHVzJ10pIHtcbiAgICBNb2R1bGVbJ3NldFN0YXR1cyddKCdSdW5uaW5nLi4uJyk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIE1vZHVsZVsnc2V0U3RhdHVzJ10oJycpO1xuICAgICAgfSwgMSk7XG4gICAgICBkb1J1bigpO1xuICAgIH0sIDEpO1xuICB9IGVsc2Uge1xuICAgIGRvUnVuKCk7XG4gIH1cbn1cbk1vZHVsZVsncnVuJ10gPSBydW47XG5cblxuZnVuY3Rpb24gZXhpdChzdGF0dXMsIGltcGxpY2l0KSB7XG5cbiAgLy8gaWYgdGhpcyBpcyBqdXN0IG1haW4gZXhpdC1pbmcgaW1wbGljaXRseSwgYW5kIHRoZSBzdGF0dXMgaXMgMCwgdGhlbiB3ZVxuICAvLyBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIGhlcmUgYW5kIGNhbiBqdXN0IGxlYXZlLiBpZiB0aGUgc3RhdHVzIGlzXG4gIC8vIG5vbi16ZXJvLCB0aG91Z2gsIHRoZW4gd2UgbmVlZCB0byByZXBvcnQgaXQuXG4gIC8vICh3ZSBtYXkgaGF2ZSB3YXJuZWQgYWJvdXQgdGhpcyBlYXJsaWVyLCBpZiBhIHNpdHVhdGlvbiBqdXN0aWZpZXMgZG9pbmcgc28pXG4gIGlmIChpbXBsaWNpdCAmJiBNb2R1bGVbJ25vRXhpdFJ1bnRpbWUnXSAmJiBzdGF0dXMgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoTW9kdWxlWydub0V4aXRSdW50aW1lJ10pIHtcbiAgfSBlbHNlIHtcblxuICAgIEFCT1JUID0gdHJ1ZTtcbiAgICBFWElUU1RBVFVTID0gc3RhdHVzO1xuICAgIFNUQUNLVE9QID0gaW5pdGlhbFN0YWNrVG9wO1xuXG4gICAgZXhpdFJ1bnRpbWUoKTtcblxuICAgIGlmIChNb2R1bGVbJ29uRXhpdCddKSBNb2R1bGVbJ29uRXhpdCddKHN0YXR1cyk7XG4gIH1cblxuICBNb2R1bGVbJ3F1aXQnXShzdGF0dXMsIG5ldyBFeGl0U3RhdHVzKHN0YXR1cykpO1xufVxuXG52YXIgYWJvcnREZWNvcmF0b3JzID0gW107XG5cbmZ1bmN0aW9uIGFib3J0KHdoYXQpIHtcbiAgaWYgKE1vZHVsZVsnb25BYm9ydCddKSB7XG4gICAgTW9kdWxlWydvbkFib3J0J10od2hhdCk7XG4gIH1cblxuICBpZiAod2hhdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0KHdoYXQpO1xuICAgIGVycih3aGF0KTtcbiAgICB3aGF0ID0gSlNPTi5zdHJpbmdpZnkod2hhdClcbiAgfSBlbHNlIHtcbiAgICB3aGF0ID0gJyc7XG4gIH1cblxuICBBQk9SVCA9IHRydWU7XG4gIEVYSVRTVEFUVVMgPSAxO1xuXG4gIHRocm93ICdhYm9ydCgnICsgd2hhdCArICcpLiBCdWlsZCB3aXRoIC1zIEFTU0VSVElPTlM9MSBmb3IgbW9yZSBpbmZvLic7XG59XG5Nb2R1bGVbJ2Fib3J0J10gPSBhYm9ydDtcblxuaWYgKE1vZHVsZVsncHJlSW5pdCddKSB7XG4gIGlmICh0eXBlb2YgTW9kdWxlWydwcmVJbml0J10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwcmVJbml0J10gPSBbTW9kdWxlWydwcmVJbml0J11dO1xuICB3aGlsZSAoTW9kdWxlWydwcmVJbml0J10ubGVuZ3RoID4gMCkge1xuICAgIE1vZHVsZVsncHJlSW5pdCddLnBvcCgpKCk7XG4gIH1cbn1cblxuXG5Nb2R1bGVbXCJub0V4aXRSdW50aW1lXCJdID0gdHJ1ZTtcblxucnVuKCk7XG5cblxuXG5cblxuLy8ge3tNT0RVTEVfQURESVRJT05TfX1cblxuXG5cblxuXG4gIHJldHVybiBGYXN0U291bmQ7XG59XG4pO1xufSkoKTtcbmlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBGYXN0U291bmQ7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSlcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gRmFzdFNvdW5kOyB9KTtcbiAgZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuICAgIGV4cG9ydHNbXCJGYXN0U291bmRcIl0gPSBGYXN0U291bmQ7XG4gICJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUdBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./unminified/fast-sound.js\n");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_fs__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9GYXN0U291bmQvZXh0ZXJuYWwgXCJmc1wiP2E0MGQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2ZzX187Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///fs\n");

/***/ })

/******/ });
});